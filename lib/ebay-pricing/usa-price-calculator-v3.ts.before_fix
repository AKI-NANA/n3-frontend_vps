/**
 * eBay USA DDPä¾¡æ ¼è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³ V3ï¼ˆåˆ©ç›Šç‡å›ºå®šç‰ˆï¼‰
 * 
 * ğŸ¯ é‡è¦ãªå¤‰æ›´:
 * **ç›®æ¨™åˆ©ç›Šç‡ã‚’å…¥åŠ›ã—ã€ãã‚Œã‚’é”æˆã™ã‚‹å•†å“ä¾¡æ ¼ã¨é€æ–™ã‚’é€†ç®—**
 * 
 * è¨ˆç®—æ–¹æ³•:
 * 1. å›ºå®šã‚³ã‚¹ãƒˆï¼ˆä»•å…¥ã‚Œå€¤ã€å®Ÿé€æ–™ã€å‡ºå“æ‰‹æ•°æ–™ï¼‰ã‚’è¨ˆç®—
 * 2. å¤‰å‹•ã‚³ã‚¹ãƒˆç‡ï¼ˆFVFã€Payoneerã€ç‚ºæ›¿æå¤±ã€å›½éš›æ‰‹æ•°æ–™ï¼‰ã‚’è¨ˆç®—
 * 3. ç›®æ¨™åˆ©ç›Šç‡ã‹ã‚‰å¿…è¦ãªç·å£²ä¸Šã‚’é€†ç®—
 * 4. å•†å“ä¾¡æ ¼ = ç·å£²ä¸Š - é€æ–™
 * 5. DDPè²»ç”¨ã‚’å•†å“ä¾¡æ ¼ã‹ã‚‰å†è¨ˆç®—
 * 6. åå¾©è¨ˆç®—ã§ç²¾åº¦ã‚’é«˜ã‚ã‚‹
 */

import { supabase } from '@/lib/supabase/client'

const CONSUMPTION_TAX_RATE = 0.1
const DDP_SERVICE_FEE = 15
const TARGET_PRODUCT_PRICE_RATIO = 0.80

export const STORE_FEES = {
  none: { name: 'ã‚¹ãƒˆã‚¢ãªã—', fvf_discount: 0 },
  basic: { name: 'Basic', fvf_discount: 0.04 },
  premium: { name: 'Premium', fvf_discount: 0.06 },
  anchor: { name: 'Anchor', fvf_discount: 0.08 },
}

export interface UsaPricingInputV3 {
  costJPY: number
  weight_kg: number
  targetMargin: number // ç›®æ¨™åˆ©ç›Šç‡ï¼ˆ%ï¼‰
  hsCode: string
  originCountry: string
  storeType: keyof typeof STORE_FEES
  fvfRate: number
  exchangeRate: number
}

export interface DetailedBreakdown {
  costJPY: number
  costUSD: number
  exchangeRate: number
  weight_kg: number
  targetMargin: number
  
  hsCode: string
  originCountry: string
  baseTariffRate: number
  additionalTariffRate: number
  totalTariffRate: number
  salesTaxRate: number
  effectiveDDPRate: number
  
  minPolicyName: string
  minBaseShipping: number
  minDDPFee: number
  minTotalShipping: number
  
  tempProductPrice: number
  requiredTariff: number
  requiredMPF: number
  requiredDDP: number
  requiredTotalShipping: number
  
  storeType: string
  baseFVF: number
  storeDiscount: number
  finalFVF: number
  
  ebayFees: {
    fvf: number
    payoneer: number
    exchangeLoss: number
    internationalFee: number
    insertionFee: number
    total: number
  }
  
  ddpCosts: {
    tariff: number
    mpf: number
    hmf: number
    serviceFee: number
    total: number
  }
  
  selectedPolicyName: string
  selectedBaseShipping: number
  selectedTotalShipping: number
  
  finalProductPrice: number
  finalShipping: number
  finalTotal: number
  productPriceRatio: number
  
  totalCosts: number
  profit: number
  profitMargin: number
  
  refundJPY: number
  refundUSD: number
  profitWithRefund: number
  profitMarginWithRefund: number
}

export interface UsaPricingResultV3 {
  success: boolean
  error?: string
  breakdown: DetailedBreakdown
  calculationSteps: Array<{
    step: number
    title: string
    description: string
    values: Array<{ label: string; value: string; formula?: string }>
  }>
}

/**
 * ç›®æ¨™åˆ©ç›Šç‡ã‹ã‚‰å•†å“ä¾¡æ ¼ã‚’é€†ç®—ã™ã‚‹åå¾©è¨ˆç®—
 */
function calculatePriceForTargetMargin(
  costUSD: number,
  baseShipping: number,
  effectiveDDPRate: number,
  finalFVF: number,
  targetMarginDecimal: number,
  shippingTotal: number,
  insertionFee: number
): { productPrice: number; totalRevenue: number; ddpCost: number } {
  const variableRate = finalFVF + 0.02 + 0.02 + 0.03 + 0.015 // FVF + Payoneer + äº¤æ›æå¤± + å›½éš›æ‰‹æ•°æ–™
  
  // åå¾©è¨ˆç®—ã§æœ€é©ãªå•†å“ä¾¡æ ¼ã‚’æ±‚ã‚ã‚‹
  let productPrice = 100 // åˆæœŸå€¤
  
  for (let i = 0; i < 10; i++) {
    // DDPè²»ç”¨ã‚’è¨ˆç®—
    const tariff = productPrice * effectiveDDPRate
    const mpf = productPrice * 0.003464
    const ddpCost = tariff + mpf + DDP_SERVICE_FEE
    
    // å›ºå®šã‚³ã‚¹ãƒˆ
    const fixedCost = costUSD + baseShipping + ddpCost + insertionFee
    
    // ç›®æ¨™åˆ©ç›Šç‡ã‹ã‚‰å¿…è¦ãªç·å£²ä¸Šã‚’é€†ç®—
    // åˆ©ç›Šç‡ = (ç·å£²ä¸Š - å›ºå®šã‚³ã‚¹ãƒˆ - å¤‰å‹•ã‚³ã‚¹ãƒˆ) / ç·å£²ä¸Š
    // åˆ©ç›Šç‡ = (ç·å£²ä¸Š - å›ºå®šã‚³ã‚¹ãƒˆ - ç·å£²ä¸ŠÃ—å¤‰å‹•ç‡) / ç·å£²ä¸Š
    // åˆ©ç›Šç‡ = 1 - å›ºå®šã‚³ã‚¹ãƒˆ/ç·å£²ä¸Š - å¤‰å‹•ç‡
    // å›ºå®šã‚³ã‚¹ãƒˆ/ç·å£²ä¸Š = 1 - åˆ©ç›Šç‡ - å¤‰å‹•ç‡
    // ç·å£²ä¸Š = å›ºå®šã‚³ã‚¹ãƒˆ / (1 - åˆ©ç›Šç‡ - å¤‰å‹•ç‡)
    const requiredRevenue = fixedCost / (1 - targetMarginDecimal - variableRate)
    
    // æ–°ã—ã„å•†å“ä¾¡æ ¼
    const newProductPrice = requiredRevenue - shippingTotal
    
    // åæŸåˆ¤å®š
    if (Math.abs(newProductPrice - productPrice) < 0.01) {
      productPrice = newProductPrice
      break
    }
    
    productPrice = newProductPrice
  }
  
  // 5ãƒ‰ãƒ«å˜ä½ã«ä¸¸ã‚ã‚‹
  productPrice = Math.round(productPrice / 5) * 5
  
  const totalRevenue = productPrice + shippingTotal
  const tariff = productPrice * effectiveDDPRate
  const mpf = productPrice * 0.003464
  const ddpCost = tariff + mpf + DDP_SERVICE_FEE
  
  return { productPrice, totalRevenue, ddpCost }
}

export async function calculateUsaPriceV3(
  input: UsaPricingInputV3
): Promise<UsaPricingResultV3> {
  try {
    const {
      costJPY,
      weight_kg,
      targetMargin,
      hsCode,
      originCountry,
      storeType,
      fvfRate,
      exchangeRate
    } = input

    console.log('ğŸš€ ============ USA DDPä¾¡æ ¼è¨ˆç®— V3ï¼ˆåˆ©ç›Šç‡å›ºå®šç‰ˆï¼‰ ============')
    console.log(`ğŸ“¦ å…¥åŠ›: ä»•å…¥${costJPY}å††, é‡é‡${weight_kg}kg, ç›®æ¨™åˆ©ç›Šç‡${targetMargin}%`)

    const calculationSteps: UsaPricingResultV3['calculationSteps'] = []
    const costUSD = costJPY / exchangeRate
    const targetMarginDecimal = targetMargin / 100

    calculationSteps.push({
      step: 1,
      title: 'åŸºæœ¬æƒ…å ±ã®ç¢ºèª',
      description: 'ä»•å…¥ã‚Œå€¤ã‚’ç±³ãƒ‰ãƒ«ã«æ›ç®—ã—ã€ç›®æ¨™åˆ©ç›Šç‡ã‚’è¨­å®šã—ã¾ã™',
      values: [
        { label: 'ä»•å…¥ã‚Œå€¤ï¼ˆå††ï¼‰', value: `Â¥${costJPY.toLocaleString()}` },
        { label: 'ç‚ºæ›¿ãƒ¬ãƒ¼ãƒˆ', value: `Â¥${exchangeRate}/USD` },
        { label: 'ä»•å…¥ã‚Œå€¤ï¼ˆUSDï¼‰', value: `$${costUSD.toFixed(2)}`, formula: `Â¥${costJPY} Ã· ${exchangeRate} = $${costUSD.toFixed(2)}` },
        { label: 'é‡é‡', value: `${weight_kg}kg` },
        { label: 'ğŸ¯ ç›®æ¨™åˆ©ç›Šç‡ï¼ˆå›ºå®šï¼‰', value: `${targetMargin}%`, formula: 'ã“ã®åˆ©ç›Šç‡ã‚’é”æˆã™ã‚‹ä¾¡æ ¼ã‚’é€†ç®—ã—ã¾ã™' }
      ]
    })

    // STEP 2: é–¢ç¨ç‡ã®å–å¾—
    const hsCodeNormalized = hsCode.replace(/\./g, '')
    const searchTerms = [hsCode, hsCodeNormalized]
    let hsData: any = null
    
    for (const term of searchTerms) {
      const { data } = await supabase
        .from('hts_codes_details')
        .select('hts_number, general_rate, description')
        .eq('hts_number', term)
        .limit(1)
        .maybeSingle()
      
      if (data) {
        const parseRate = (rate: string | null): number => {
          if (!rate || rate === 'Free') return 0
          const match = rate.match(/([\d.]+)%?/)
          return match ? parseFloat(match[1]) / 100 : 0
        }
        
        hsData = {
          code: data.hts_number,
          base_duty: parseRate(data.general_rate),
          description: data.description
        }
        break
      }
    }

    if (!hsData) {
      return { success: false, error: `HTSã‚³ãƒ¼ãƒ‰ ${hsCode} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“` } as UsaPricingResultV3
    }

    const { data: countryTariff } = await supabase
      .from('country_additional_tariffs')
      .select('country_code, additional_rate, tariff_type')
      .eq('country_code', originCountry)
      .eq('is_active', true)
      .single()

    const baseTariffRate = hsData.base_duty
    const additionalTariffRate = countryTariff ? parseFloat(countryTariff.additional_rate as string) : 0
    const totalTariffRate = baseTariffRate + additionalTariffRate
    const salesTaxRate = 0.08
    const effectiveDDPRate = totalTariffRate + salesTaxRate

    calculationSteps.push({
      step: 2,
      title: 'é–¢ç¨ç‡ã®è¨ˆç®—',
      description: `HTSã‚³ãƒ¼ãƒ‰${hsCode}ã¨åŸç”£å›½${originCountry}ã‹ã‚‰é–¢ç¨ç‡ã‚’ç®—å‡º`,
      values: [
        { label: 'HTSã‚³ãƒ¼ãƒ‰', value: hsCode },
        { label: 'åŸç”£å›½', value: originCountry },
        { label: 'åŸºæœ¬é–¢ç¨ç‡', value: `${(baseTariffRate * 100).toFixed(2)}%` },
        ...(additionalTariffRate > 0 ? [
          { label: 'è¿½åŠ é–¢ç¨ç‡', value: `${(additionalTariffRate * 100).toFixed(2)}%` },
          { label: 'åˆè¨ˆé–¢ç¨ç‡', value: `${(totalTariffRate * 100).toFixed(2)}%` }
        ] : []),
        { label: 'è²©å£²ç¨ç‡', value: `${(salesTaxRate * 100).toFixed(2)}%` },
        { label: 'å®ŸåŠ¹DDPç‡', value: `${(effectiveDDPRate * 100).toFixed(2)}%`, formula: `é–¢ç¨${(totalTariffRate * 100).toFixed(2)}% + è²©å£²ç¨${(salesTaxRate * 100).toFixed(2)}%` }
      ]
    })

    // STEP 3: æœ€å®‰é€æ–™ãƒãƒªã‚·ãƒ¼å–å¾—
    const estimatedProductPrice = Math.ceil(costUSD * 2.0)
    
    const { data: minPolicy, error: minError } = await supabase
      .from('usa_ddp_rates')
      .select('*')
      .lte('weight_min_kg', weight_kg)
      .gte('weight_max_kg', weight_kg)
      .lte('product_price_usd', estimatedProductPrice)
      .order('total_shipping_usd', { ascending: true })
      .limit(1)
      .maybeSingle()

    if (minError || !minPolicy) {
      return { success: false, error: `é‡é‡${weight_kg}kgã®é…é€ãƒãƒªã‚·ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“` } as UsaPricingResultV3
    }

    calculationSteps.push({
      step: 3,
      title: 'æœ€å®‰é€æ–™ãƒãƒªã‚·ãƒ¼ã®é¸æŠ',
      description: 'é‡é‡å¸¯ã«å¯¾å¿œã™ã‚‹æœ€ã‚‚å®‰ã„é…é€ãƒãƒªã‚·ãƒ¼ã‚’å–å¾—',
      values: [
        { label: 'ãƒãƒªã‚·ãƒ¼å', value: minPolicy.weight_band_name },
        { label: 'å®Ÿé€æ–™', value: `$${minPolicy.base_shipping_usd.toFixed(2)}` },
        { label: 'DDPä¸Šä¹—ã›', value: `$${(minPolicy.total_shipping_usd - minPolicy.base_shipping_usd).toFixed(2)}` },
        { label: 'é€æ–™åˆè¨ˆ', value: `$${minPolicy.total_shipping_usd.toFixed(2)}` }
      ]
    })

    // STEP 4: ã‚¹ãƒˆã‚¢å‰²å¼•é©ç”¨
    const storeFee = STORE_FEES[storeType]
    const finalFVF = Math.max(0, fvfRate - storeFee.fvf_discount)

    calculationSteps.push({
      step: 4,
      title: 'ã‚¹ãƒˆã‚¢å‰²å¼•ã®é©ç”¨',
      description: 'eBayã‚¹ãƒˆã‚¢ãƒ—ãƒ©ãƒ³ã«ã‚ˆã‚‹FVFå‰²å¼•ã‚’è¨ˆç®—',
      values: [
        { label: 'ã‚¹ãƒˆã‚¢ã‚¿ã‚¤ãƒ—', value: storeFee.name },
        { label: 'åŸºæœ¬FVFç‡', value: `${(fvfRate * 100).toFixed(2)}%` },
        { label: 'ã‚¹ãƒˆã‚¢å‰²å¼•', value: `-${(storeFee.fvf_discount * 100).toFixed(2)}%` },
        { label: 'æœ€çµ‚FVFç‡', value: `${(finalFVF * 100).toFixed(2)}%`, formula: `${(fvfRate * 100).toFixed(2)}% - ${(storeFee.fvf_discount * 100).toFixed(2)}% = ${(finalFVF * 100).toFixed(2)}%` }
      ]
    })

    // STEP 5: ç›®æ¨™åˆ©ç›Šç‡ã‹ã‚‰å•†å“ä¾¡æ ¼ã‚’é€†ç®—
    const insertionFeeUSD = 0.35
    
    const { productPrice: initialPrice, totalRevenue: initialRevenue, ddpCost: initialDDP } = 
      calculatePriceForTargetMargin(
        costUSD,
        minPolicy.base_shipping_usd,
        effectiveDDPRate,
        finalFVF,
        targetMarginDecimal,
        minPolicy.total_shipping_usd,
        insertionFeeUSD
      )

    calculationSteps.push({
      step: 5,
      title: 'ğŸ¯ ç›®æ¨™åˆ©ç›Šç‡ã‹ã‚‰å•†å“ä¾¡æ ¼ã‚’é€†ç®—',
      description: `ç›®æ¨™åˆ©ç›Šç‡${targetMargin}%ã‚’é”æˆã™ã‚‹ãŸã‚ã®å•†å“ä¾¡æ ¼ã‚’åå¾©è¨ˆç®—ã§æ±‚ã‚ã¾ã™`,
      values: [
        { label: 'è¨ˆç®—æ–¹æ³•', value: 'åå¾©è¨ˆç®—ï¼ˆ10å›ï¼‰', formula: 'ç·å£²ä¸Š = å›ºå®šã‚³ã‚¹ãƒˆ / (1 - ç›®æ¨™åˆ©ç›Šç‡ - å¤‰å‹•ã‚³ã‚¹ãƒˆç‡)' },
        { label: 'å¤‰å‹•ã‚³ã‚¹ãƒˆç‡', value: `${((finalFVF + 0.02 + 0.02 + 0.03 + 0.015) * 100).toFixed(2)}%`, formula: 'FVF + Payoneer(2%) + ç‚ºæ›¿æå¤±(3%) + å›½éš›æ‰‹æ•°æ–™(1.5%)' },
        { label: 'ç®—å‡ºã•ã‚ŒãŸå•†å“ä¾¡æ ¼', value: `$${initialPrice.toFixed(2)}` },
        { label: 'é€æ–™', value: `$${minPolicy.total_shipping_usd.toFixed(2)}` },
        { label: 'ç·å£²ä¸Š', value: `$${initialRevenue.toFixed(2)}` }
      ]
    })

    // STEP 6: æœ€é©ãªé…é€ãƒãƒªã‚·ãƒ¼é¸æŠï¼ˆ1ã€œ2æ®µéšä¸Šï¼‰
    const { data: allPolicies } = await supabase
      .from('usa_ddp_rates')
      .select('*')
      .lte('weight_min_kg', weight_kg)
      .gte('weight_max_kg', weight_kg)
      .gte('product_price_usd', initialPrice)
      .order('total_shipping_usd', { ascending: true })
      .limit(10)

    let selectedPolicy = minPolicy
    if (allPolicies && allPolicies.length > 1) {
      const targetIndex = Math.min(1, allPolicies.length - 1)
      selectedPolicy = allPolicies[targetIndex]
    }

    calculationSteps.push({
      step: 6,
      title: 'æœ€é©ãªé…é€ãƒãƒªã‚·ãƒ¼ã®é¸æŠ',
      description: 'å®Ÿé€æ–™+DDPè²»ç”¨ã‚ˆã‚Š1ã€œ2æ®µéšä¸Šã®ãƒãƒªã‚·ãƒ¼ã‚’é¸æŠ',
      values: [
        { label: 'é¸æŠãƒãƒªã‚·ãƒ¼', value: selectedPolicy.weight_band_name },
        { label: 'å•†å“ä¾¡æ ¼å¸¯', value: `$${selectedPolicy.product_price_usd}ä»¥ä¸‹` },
        { label: 'å®Ÿé€æ–™', value: `$${selectedPolicy.base_shipping_usd.toFixed(2)}` },
        { label: 'é€æ–™åˆè¨ˆ', value: `$${selectedPolicy.total_shipping_usd.toFixed(2)}` }
      ]
    })

    // STEP 7: é¸æŠã—ãŸãƒãƒªã‚·ãƒ¼ã§ä¾¡æ ¼ã‚’å†è¨ˆç®—
    const { productPrice: finalProductPrice, totalRevenue: finalTotalRevenue, ddpCost: finalDDPCost } = 
      calculatePriceForTargetMargin(
        costUSD,
        selectedPolicy.base_shipping_usd,
        effectiveDDPRate,
        finalFVF,
        targetMarginDecimal,
        selectedPolicy.total_shipping_usd,
        insertionFeeUSD
      )

    const productPriceRatio = finalProductPrice / finalTotalRevenue

    calculationSteps.push({
      step: 7,
      title: 'æœ€çµ‚ä¾¡æ ¼ã®æ±ºå®š',
      description: 'é¸æŠã—ãŸé…é€ãƒãƒªã‚·ãƒ¼ã§å•†å“ä¾¡æ ¼ã‚’æœ€çµ‚æ±ºå®š',
      values: [
        { label: 'å•†å“ä¾¡æ ¼', value: `$${finalProductPrice.toFixed(2)}` },
        { label: 'é€æ–™', value: `$${selectedPolicy.total_shipping_usd.toFixed(2)}` },
        { label: 'ç·å£²ä¸Š', value: `$${finalTotalRevenue.toFixed(2)}` },
        { label: 'å•†å“ä¾¡æ ¼æ¯”ç‡', value: `${(productPriceRatio * 100).toFixed(1)}%` }
      ]
    })

    // STEP 8: DDPé–¢é€£ã‚³ã‚¹ãƒˆ
    const finalTariff = finalProductPrice * totalTariffRate
    const finalSalesTax = finalProductPrice * salesTaxRate
    const finalMPF = finalProductPrice * 0.003464
    const finalDDP = finalTariff + finalSalesTax + finalMPF + DDP_SERVICE_FEE

    calculationSteps.push({
      step: 8,
      title: 'DDPé–¢é€£ã‚³ã‚¹ãƒˆã®è¨ˆç®—',
      description: 'æœ€çµ‚å•†å“ä¾¡æ ¼ã«åŸºã¥ã„ã¦DDPè²»ç”¨ã‚’è¨ˆç®—',
      values: [
        { label: 'é–¢ç¨', value: `$${finalTariff.toFixed(2)}`, formula: `$${finalProductPrice.toFixed(2)} Ã— ${(totalTariffRate * 100).toFixed(2)}%` },
        { label: 'è²©å£²ç¨', value: `$${finalSalesTax.toFixed(2)}`, formula: `$${finalProductPrice.toFixed(2)} Ã— ${(salesTaxRate * 100).toFixed(2)}%` },
        { label: 'MPF', value: `$${finalMPF.toFixed(2)}`, formula: `$${finalProductPrice.toFixed(2)} Ã— 0.3464%` },
        { label: 'é€šé–¢æ‰‹æ•°æ–™', value: `$${DDP_SERVICE_FEE.toFixed(2)}` },
        { label: 'DDPåˆè¨ˆ', value: `$${finalDDP.toFixed(2)}` }
      ]
    })

    // STEP 9: eBayæ‰‹æ•°æ–™
    const fvfFee = finalTotalRevenue * finalFVF
    const payoneerFee = finalTotalRevenue * 0.02
    const exchangeLossFee = finalTotalRevenue * 0.03
    const internationalFee = finalTotalRevenue * 0.015
    const ebayFeesTotal = fvfFee + payoneerFee + exchangeLossFee + internationalFee + insertionFeeUSD

    calculationSteps.push({
      step: 9,
      title: 'eBayæ‰‹æ•°æ–™ã®è¨ˆç®—',
      description: 'ç·å£²ä¸Šã«å¯¾ã™ã‚‹eBayé–¢é€£ã®å„ç¨®æ‰‹æ•°æ–™ã‚’è¨ˆç®—',
      values: [
        { label: 'FVF', value: `$${fvfFee.toFixed(2)}`, formula: `$${finalTotalRevenue.toFixed(2)} Ã— ${(finalFVF * 100).toFixed(2)}%` },
        { label: 'Payoneer', value: `$${payoneerFee.toFixed(2)}`, formula: `$${finalTotalRevenue.toFixed(2)} Ã— 2%` },
        { label: 'ç‚ºæ›¿æå¤±', value: `$${exchangeLossFee.toFixed(2)}`, formula: `$${finalTotalRevenue.toFixed(2)} Ã— 3%` },
        { label: 'å›½éš›æ‰‹æ•°æ–™', value: `$${internationalFee.toFixed(2)}`, formula: `$${finalTotalRevenue.toFixed(2)} Ã— 1.5%` },
        { label: 'å‡ºå“æ‰‹æ•°æ–™', value: `$${insertionFeeUSD.toFixed(2)}` },
        { label: 'eBayæ‰‹æ•°æ–™åˆè¨ˆ', value: `$${ebayFeesTotal.toFixed(2)}` }
      ]
    })

    // STEP 10: åˆ©ç›Šè¨ˆç®—
    const totalCosts = costUSD + selectedPolicy.base_shipping_usd + finalDDP + ebayFeesTotal
    const profit = finalTotalRevenue - totalCosts
    const profitMargin = (profit / finalTotalRevenue) * 100

    // æ¶ˆè²»ç¨é‚„ä»˜
    const estimatedRevenue = costUSD * exchangeRate * 2.5
    const estimatedFVF = estimatedRevenue * finalFVF
    const insertionFeeJPY = insertionFeeUSD * exchangeRate
    const refundableFees = estimatedFVF + insertionFeeJPY
    const taxableAmount = (costUSD * exchangeRate) + refundableFees
    const refundJPY = taxableAmount * (CONSUMPTION_TAX_RATE / (1 + CONSUMPTION_TAX_RATE))
    const refundUSD = refundJPY / exchangeRate
    const profitWithRefund = profit + refundUSD
    const profitMarginWithRefund = (profitWithRefund / finalTotalRevenue) * 100

    calculationSteps.push({
      step: 10,
      title: 'âœ… æœ€çµ‚åˆ©ç›Šã®ç¢ºèª',
      description: `ç›®æ¨™åˆ©ç›Šç‡${targetMargin}%ãŒé”æˆã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¾ã™`,
      values: [
        { label: 'ç·å£²ä¸Š', value: `$${finalTotalRevenue.toFixed(2)}` },
        { label: 'ç·ã‚³ã‚¹ãƒˆ', value: `$${totalCosts.toFixed(2)}`, formula: `ä»•å…¥$${costUSD.toFixed(2)} + é€æ–™$${selectedPolicy.base_shipping_usd.toFixed(2)} + DDP$${finalDDP.toFixed(2)} + eBayæ‰‹æ•°æ–™$${ebayFeesTotal.toFixed(2)}` },
        { label: 'åˆ©ç›Šï¼ˆé‚„ä»˜å‰ï¼‰', value: `$${profit.toFixed(2)}` },
        { label: 'ğŸ¯ åˆ©ç›Šç‡ï¼ˆé‚„ä»˜å‰ï¼‰', value: `${profitMargin.toFixed(2)}%`, formula: `ç›®æ¨™: ${targetMargin}% â†’ é”æˆ: ${profitMargin.toFixed(2)}%` },
        { label: 'æ¶ˆè²»ç¨é‚„ä»˜', value: `$${refundUSD.toFixed(2)} (Â¥${refundJPY.toFixed(0)})` },
        { label: 'åˆ©ç›Šï¼ˆé‚„ä»˜å¾Œï¼‰', value: `$${profitWithRefund.toFixed(2)}` },
        { label: 'åˆ©ç›Šç‡ï¼ˆé‚„ä»˜å¾Œï¼‰', value: `${profitMarginWithRefund.toFixed(2)}%` }
      ]
    })

    const breakdown: DetailedBreakdown = {
      costJPY,
      costUSD,
      exchangeRate,
      weight_kg,
      targetMargin,
      hsCode,
      originCountry,
      baseTariffRate,
      additionalTariffRate,
      totalTariffRate,
      salesTaxRate,
      effectiveDDPRate,
      minPolicyName: minPolicy.weight_band_name,
      minBaseShipping: minPolicy.base_shipping_usd,
      minDDPFee: minPolicy.total_shipping_usd - minPolicy.base_shipping_usd,
      minTotalShipping: minPolicy.total_shipping_usd,
      tempProductPrice: initialPrice,
      requiredTariff: initialPrice * totalTariffRate,
      requiredMPF: initialPrice * 0.003464,
      requiredDDP: initialDDP,
      requiredTotalShipping: minPolicy.base_shipping_usd + initialDDP,
      storeType: storeFee.name,
      baseFVF: fvfRate,
      storeDiscount: storeFee.fvf_discount,
      finalFVF,
      ebayFees: {
        fvf: fvfFee,
        payoneer: payoneerFee,
        exchangeLoss: exchangeLossFee,
        internationalFee,
        insertionFee: insertionFeeUSD,
        total: ebayFeesTotal
      },
      ddpCosts: {
        tariff: finalTariff,
        mpf: finalMPF,
        hmf: 0,
        serviceFee: DDP_SERVICE_FEE,
        total: finalDDP
      },
      selectedPolicyName: selectedPolicy.policy_name,
      selectedBaseShipping: selectedPolicy.base_shipping_usd,
      selectedTotalShipping: selectedPolicy.total_shipping_usd,
      finalProductPrice,
      finalShipping: selectedPolicy.total_shipping_usd,
      finalTotal: finalTotalRevenue,
      productPriceRatio,
      totalCosts,
      profit,
      profitMargin,
      refundJPY,
      refundUSD,
      profitWithRefund,
      profitMarginWithRefund
    }

    // ğŸ†• èµ¤å­—ãƒã‚§ãƒƒã‚¯
    if (profit < 0) {
      console.warn(`âš ï¸ èµ¤å­—: åˆ©ç›Š${profit.toFixed(2)} (${profitMargin.toFixed(1)}%)`)
      
      // èµ¤å­—ã§ã‚‚å…¨ã¦ã®è¨ˆç®—çµæœã‚’è¿”ã™ï¼ˆUIã§è¡¨ç¤ºã™ã‚‹ãŸã‚ï¼‰
      return {
        success: false,  // â† falseã ãŒã€ãƒ‡ãƒ¼ã‚¿ã¯å…¨ã¦å«ã‚€
        error: `èµ¤å­—ã®ãŸã‚å‡ºå“ä¸å¯ã€‚åˆ©ç›Š: ${profit.toFixed(2)} (${profitMargin.toFixed(1)}%)`,
        profitUSD: profit,
        profitMargin,
        totalRevenue: finalTotalRevenue,
        breakdown,
        calculationSteps
      } as UsaPricingResultV3
    }

    return {
      success: true,
      breakdown,
      calculationSteps
    }
  } catch (error: any) {
    console.error('âŒ è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error)
    return {
      success: false,
      error: `è¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${error?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`
    } as UsaPricingResultV3
  }
}
