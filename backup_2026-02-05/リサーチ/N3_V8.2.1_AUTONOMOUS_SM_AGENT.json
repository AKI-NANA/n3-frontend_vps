{
  "name": "ã€V8.2.1-AUTONOMOUSã€‘SM AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ»ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹åˆ¤å®š",
  "description": "N3 Empire OS V8.2.1-Autonomous: n8n AI Agentã«ã‚ˆã‚‹ã‚¿ã‚¤ãƒˆãƒ«ãƒ»ç”»åƒãƒ»Specsç…§åˆã€ç¢ºä¿¡åº¦ä½Žã„å ´åˆã¯HitL",
  "_version": "8.2.1-autonomous",
  "_27d_compliance": ["dim3_auth_gate", "dim13_decision_trace", "dim5_hitl", "dim21_data_trust"],

  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "sm-agent-judge",
        "options": { "responseMode": "responseNode" }
      },
      "name": "Webhook: SM AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "webhookId": "sm-agent-judge"
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ðŸ” 27æ¬¡å…ƒ-3: HMACèªè¨¼ + åˆæœŸåŒ–\n// ============================================================================\nconst crypto = require('crypto');\nconst body = $input.first().json.body || $input.first().json;\nconst headers = $input.first().json.headers || {};\n\nconst signature = headers['x-n3-signature'] || headers['X-N3-Signature'];\nconst timestamp = headers['x-n3-timestamp'] || headers['X-N3-Timestamp'];\nconst secret = $env.N8N_HMAC_SECRET;\n\nif (!secret) return [{ json: { error: true, code: 'CONFIG_ERROR', message: 'N8N_HMAC_SECRETæœªè¨­å®š' }}];\nif (!signature || !timestamp) return [{ json: { error: true, code: 'AUTH_REQUIRED', message: 'èªè¨¼ãƒ˜ãƒƒãƒ€ãƒ¼æ¬ è½' }}];\nif (Math.abs(Date.now() - parseInt(timestamp)) > 300000) return [{ json: { error: true, code: 'TIMESTAMP_EXPIRED', message: 'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æœŸé™åˆ‡ã‚Œ' }}];\n\nconst computedHmac = crypto.createHmac('sha256', secret).update(timestamp + '.' + JSON.stringify(body)).digest('hex');\nif (signature !== computedHmac) return [{ json: { error: true, code: 'HMAC_INVALID', message: 'HMACæ¤œè¨¼å¤±æ•—' }}];\n\n// å…¥åŠ›æ¤œè¨¼\nconst productId = body.product_id;\nconst searchQuery = body.search_query || body.title;\nconst candidateItems = body.candidate_items || [];\nconst productImage = body.product_image_url;\nconst productSpecs = body.item_specifics || {};\nconst tenantId = body.user_id || 'default';\n\nif (!productId) return [{ json: { error: true, code: 'MISSING_PARAM', message: 'product_idå¿…é ˆ' }}];\nif (!searchQuery && candidateItems.length === 0) return [{ json: { error: true, code: 'MISSING_PARAM', message: 'search_query ã¾ãŸã¯ candidate_itemså¿…é ˆ' }}];\n\nreturn [{ json: {\n  product_id: productId,\n  search_query: searchQuery,\n  candidate_items: candidateItems,\n  product_image_url: productImage,\n  product_specs: productSpecs,\n  tenant_id: tenantId,\n  confidence_threshold: body.confidence_threshold || 75,\n  _auth_verified: true\n}}];"
      },
      "name": "ðŸ” èªè¨¼ + åˆæœŸåŒ–",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "error", "leftValue": "={{ $json.error }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" }}]
        }
      },
      "name": "ã‚¨ãƒ©ãƒ¼ï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.message, code: $json.code }) }}",
        "options": { "responseCode": "={{ $json.code === 'AUTH_REQUIRED' || $json.code === 'HMAC_INVALID' ? 403 : 400 }}" }
      },
      "name": "ã‚¨ãƒ©ãƒ¼å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "has-candidates", "leftValue": "={{ $json.candidate_items?.length || 0 }}", "rightValue": 0, "operator": { "type": "number", "operation": "larger" }}]
        }
      },
      "name": "å€™è£œã‚ã‚Šï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.N3_API_URL }}/api/ebay/browse-search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            { "name": "q", "value": "={{ $json.search_query }}" },
            { "name": "limit", "value": "20" },
            { "name": "filter", "value": "conditionIds:{1000|1500|2000|2500}" }
          ]
        },
        "options": { "timeout": 30000 }
      },
      "name": "ðŸ” eBay Browse APIæ¤œç´¢",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "jsCode": "// æ¤œç´¢çµæžœã‚’å€™è£œãƒªã‚¹ãƒˆã«ãƒžãƒ¼ã‚¸\nconst prevData = $node['ðŸ” èªè¨¼ + åˆæœŸåŒ–'].json;\nconst searchResult = $input.first().json;\n\nconst items = searchResult.itemSummaries || searchResult.items || [];\nconst candidates = items.slice(0, 20).map(item => ({\n  item_id: item.itemId || item.id,\n  title: item.title,\n  price: parseFloat(item.price?.value || item.currentBidPrice?.value || 0),\n  currency: item.price?.currency || 'USD',\n  image_url: item.image?.imageUrl || item.thumbnailImages?.[0]?.imageUrl,\n  condition: item.condition,\n  seller_id: item.seller?.username,\n  item_specifics: item.localizedAspects?.reduce((acc, asp) => { acc[asp.name] = asp.value; return acc; }, {}) || {},\n  item_web_url: item.itemWebUrl\n}));\n\nreturn [{ json: { ...prevData, candidate_items: [...(prevData.candidate_items || []), ...candidates].slice(0, 30) }}];"
      },
      "name": "ðŸ“‹ å€™è£œãƒªã‚¹ãƒˆæº–å‚™",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn [{ json: data }];"
      },
      "name": "æ—¢å­˜å€™è£œä½¿ç”¨",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Content-Type", "value": "application/json" },
            { "name": "x-goog-api-key", "value": "={{ $env.GEMINI_API_KEY }}" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ contents: [{ parts: [{ text: '## SM(Selsimileer) ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹åˆ¤å®šã‚¿ã‚¹ã‚¯\\n\\nã‚ãªãŸã¯è¶Šå¢ƒECã®å•†å“ç…§åˆã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã§ã™ã€‚å‡ºå“è€…ã®å•†å“æƒ…å ±ã¨ã€eBayæ¤œç´¢çµæžœã®å€™è£œãƒªã‚¹ãƒˆã‚’ç…§åˆã—ã€ã€Œæ­£ã—ã„ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹å•†å“ã€ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ã€‚\\n\\n### å‡ºå“å•†å“æƒ…å ±\\n- æ¤œç´¢ã‚¯ã‚¨ãƒª: ' + $json.search_query + '\\n- Item Specifics: ' + JSON.stringify($json.product_specs || {}) + '\\n\\n### å€™è£œãƒªã‚¹ãƒˆï¼ˆæœ€å¤§30ä»¶ï¼‰\\n' + JSON.stringify($json.candidate_items?.slice(0, 15) || [], null, 2) + '\\n\\n### åˆ¤å®šåŸºæº–\\n1. ã‚¿ã‚¤ãƒˆãƒ«ä¸€è‡´åº¦: åž‹ç•ªã€ãƒ–ãƒ©ãƒ³ãƒ‰åã€ãƒ¢ãƒ‡ãƒ«åã®ä¸€è‡´\\n2. Item Specificsä¸€è‡´åº¦: Brand, MPN, Model, Colorç­‰ã®å±žæ€§ç…§åˆ\\n3. ä¾¡æ ¼å¸¯ã®å¦¥å½“æ€§: æ¥µç«¯ãªä¾¡æ ¼å·®ã¯èª¤ãƒžãƒƒãƒã®å¯èƒ½æ€§\\n4. ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³é©åˆæ€§: New/Usedç­‰ã®çŠ¶æ…‹\\n\\n### å‡ºåŠ›å½¢å¼ï¼ˆJSONï¼‰\\n```json\\n{\\n  \"selected_item_id\": \"å€™è£œã®item_idï¼ˆä¸€è‡´ãªã—ãªã‚‰nullï¼‰\",\\n  \"selected_title\": \"é¸æŠžã—ãŸå•†å“ã‚¿ã‚¤ãƒˆãƒ«\",\\n  \"title_match_score\": 0-100,\\n  \"specs_match_score\": 0-100,\\n  \"overall_confidence\": 0-100,\\n  \"matching_points\": [\"ä¸€è‡´ã—ãŸå±žæ€§ãƒªã‚¹ãƒˆ\"],\\n  \"diverging_points\": [\"ä¸ä¸€è‡´ãƒ»æ‡¸å¿µç‚¹ãƒªã‚¹ãƒˆ\"],\\n  \"reasoning\": \"åˆ¤å®šç†ç”±ã®è©³ç´°èª¬æ˜Ž\"\\n}\\n```\\n\\nç¢ºä¿¡åº¦75ç‚¹æœªæº€ã®å ´åˆã¯ã€äººé–“ã«ã‚ˆã‚‹ç¢ºèªã‚’æŽ¨å¥¨ã™ã‚‹æ—¨ã‚’reasoningã«å«ã‚ã¦ãã ã•ã„ã€‚' }] }], generationConfig: { temperature: 0.2, maxOutputTokens: 2048 } }) }}",
        "options": { "timeout": 60000 }
      },
      "name": "ðŸ§  Gemini Pro: ã‚¿ã‚¤ãƒˆãƒ«ãƒ»Specsç…§åˆ",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ðŸ“Š AIåˆ¤å®šçµæžœãƒ‘ãƒ¼ã‚¹ + ã‚¹ã‚³ã‚¢è¨ˆç®—\n// ============================================================================\nconst prevData = $node['å€™è£œã‚ã‚Šï¼Ÿ'].json.candidate_items ? $node['æ—¢å­˜å€™è£œä½¿ç”¨'].json : $node['ðŸ“‹ å€™è£œãƒªã‚¹ãƒˆæº–å‚™'].json;\nconst aiResponse = $input.first().json;\n\nlet judgment = {\n  selected_item_id: null,\n  selected_title: null,\n  title_match_score: 0,\n  specs_match_score: 0,\n  overall_confidence: 0,\n  matching_points: [],\n  diverging_points: [],\n  reasoning: 'AIè§£æžå¤±æ•—'\n};\n\ntry {\n  const text = aiResponse.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n  const match = text.match(/```json\\n?([\\s\\S]*?)\\n?```/) || text.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    const parsed = JSON.parse(match[1] || match[0]);\n    judgment = { ...judgment, ...parsed };\n  }\n} catch (e) {\n  judgment.reasoning = 'JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ' + e.message;\n}\n\n// é¸æŠžã•ã‚ŒãŸå€™è£œã®è©³ç´°ã‚’å–å¾—\nlet selectedCandidate = null;\nif (judgment.selected_item_id) {\n  selectedCandidate = prevData.candidate_items?.find(c => c.item_id === judgment.selected_item_id);\n}\n\n// HitLåˆ¤å®š\nconst requiresHitL = judgment.overall_confidence < prevData.confidence_threshold;\n\nreturn [{ json: {\n  ...prevData,\n  judgment: judgment,\n  selected_candidate: selectedCandidate,\n  requires_hitl: requiresHitL,\n  hitl_reason: requiresHitL ? `ç¢ºä¿¡åº¦ ${judgment.overall_confidence}ç‚¹ < é–¾å€¤ ${prevData.confidence_threshold}ç‚¹` : null\n}}];"
      },
      "name": "ðŸ“Š AIåˆ¤å®šçµæžœãƒ‘ãƒ¼ã‚¹",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "has-image", "leftValue": "={{ $json.product_image_url }}", "rightValue": "", "operator": { "type": "string", "operation": "notEquals" }}]
        }
      },
      "name": "ç”»åƒã‚ã‚Šï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-vision:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Content-Type", "value": "application/json" },
            { "name": "x-goog-api-key", "value": "={{ $env.GEMINI_API_KEY }}" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ contents: [{ parts: [{ text: '2ã¤ã®å•†å“ç”»åƒã‚’æ¯”è¼ƒã—ã€åŒä¸€å•†å“ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚\\n\\nåˆ¤å®šåŸºæº–:\\n- å½¢çŠ¶ãƒ»ãƒ‡ã‚¶ã‚¤ãƒ³ã®ä¸€è‡´\\n- ãƒ–ãƒ©ãƒ³ãƒ‰ãƒ­ã‚´ãƒ»åž‹ç•ªè¡¨ç¤º\\n- è‰²ãƒ»ç´ æã®ä¸€è‡´\\n- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ»ä»˜å±žå“\\n\\nå‡ºåŠ›å½¢å¼ï¼ˆJSONï¼‰:\\n{\\n  \"image_match_score\": 0-100,\\n  \"is_same_product\": true/false,\\n  \"visual_matching_points\": [],\\n  \"visual_diverging_points\": [],\\n  \"reasoning\": \"åˆ¤å®šç†ç”±\"\\n}' }, { inline_data: { mime_type: 'image/jpeg', data: '' } }] }], generationConfig: { temperature: 0.1, maxOutputTokens: 1024 } }) }}",
        "options": { "timeout": 60000 }
      },
      "name": "ðŸ–¼ï¸ Gemini Vision: ç”»åƒæ¯”è¼ƒ",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true,
      "notes": "[TODO] å®Ÿéš›ã®ç”»åƒãƒ‡ãƒ¼ã‚¿æ³¨å…¥ãŒå¿…è¦ã€‚ç¾åœ¨ã¯ã‚¹ã‚­ãƒƒãƒ—"
    },

    {
      "parameters": {
        "jsCode": "// ç”»åƒæ¯”è¼ƒçµæžœã‚’ãƒžãƒ¼ã‚¸ï¼ˆã‚¹ã‚­ãƒƒãƒ—ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰\nconst prevData = $node['ðŸ“Š AIåˆ¤å®šçµæžœãƒ‘ãƒ¼ã‚¹'].json;\nconst visionResult = $input.first().json;\n\nlet imageScore = 50;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä¸­ç«‹å€¤\ntry {\n  const text = visionResult.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n  const match = text.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    const parsed = JSON.parse(match[0]);\n    imageScore = parsed.image_match_score || 50;\n  }\n} catch (e) {\n  // Vision APIã‚¨ãƒ©ãƒ¼ã¯è­¦å‘Šã®ã¿\n}\n\n// ç·åˆã‚¹ã‚³ã‚¢å†è¨ˆç®—ï¼ˆé‡ã¿ä»˜ã‘ï¼‰\nconst titleWeight = 0.4;\nconst specsWeight = 0.35;\nconst imageWeight = 0.25;\n\nconst finalConfidence = Math.round(\n  prevData.judgment.title_match_score * titleWeight +\n  prevData.judgment.specs_match_score * specsWeight +\n  imageScore * imageWeight\n);\n\nreturn [{ json: {\n  ...prevData,\n  judgment: {\n    ...prevData.judgment,\n    image_match_score: imageScore,\n    overall_confidence: finalConfidence\n  },\n  requires_hitl: finalConfidence < prevData.confidence_threshold,\n  hitl_reason: finalConfidence < prevData.confidence_threshold ? \n    `ç·åˆç¢ºä¿¡åº¦ ${finalConfidence}ç‚¹ < é–¾å€¤ ${prevData.confidence_threshold}ç‚¹` : null\n}}];"
      },
      "name": "ðŸ“Š ã‚¹ã‚³ã‚¢çµ±åˆï¼ˆç”»åƒè¾¼ã¿ï¼‰",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "jsCode": "// ç”»åƒãªã—ã®å ´åˆã¯ãã®ã¾ã¾\nconst data = $input.first().json;\nreturn [{ json: data }];"
      },
      "name": "ç”»åƒã‚¹ã‚­ãƒƒãƒ—",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO ai_decision_traces (tenant_id, workflow_id, workflow_name, decision_point, input_data, ai_model, ai_prompt_hash, ai_response, reasoning, confidence_score, decision_outcome, escalation_reason) VALUES ($1, $2, $3, 'sm_reference_selection', $4::jsonb, 'gemini-1.5-pro', $5, $6::jsonb, $7, $8, $9, $10) RETURNING trace_id",
        "options": { "queryParams": "={{ [$json.tenant_id, $workflow.id, $workflow.name, JSON.stringify({ product_id: $json.product_id, search_query: $json.search_query, candidates_count: $json.candidate_items?.length || 0 }), require('crypto').createHash('sha256').update('sm_reference_v1').digest('hex').substring(0, 16), JSON.stringify($json.judgment), $json.judgment.reasoning, $json.judgment.overall_confidence, $json.requires_hitl ? 'escalated' : 'approved', $json.hitl_reason] }}" }
      },
      "name": "ðŸ“ Decision Traceè¨˜éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }},
      "continueOnFail": true
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO sm_reference_judgments (tenant_id, product_id, search_query, candidate_items, selected_reference_id, selected_reference_title, selected_reference_price, title_match_score, image_match_score, specs_match_score, overall_confidence, matching_points, diverging_points, ai_reasoning, requires_human_review, ai_trace_id) VALUES ($1, $2, $3, $4::jsonb, $5, $6, $7, $8, $9, $10, $11, $12::jsonb, $13::jsonb, $14, $15, $16) RETURNING id",
        "options": { "queryParams": "={{ [$json.tenant_id, $json.product_id, $json.search_query, JSON.stringify($json.candidate_items?.slice(0, 10) || []), $json.judgment.selected_item_id, $json.judgment.selected_title || $json.selected_candidate?.title, $json.selected_candidate?.price, $json.judgment.title_match_score, $json.judgment.image_match_score || 50, $json.judgment.specs_match_score, $json.judgment.overall_confidence, JSON.stringify($json.judgment.matching_points || []), JSON.stringify($json.judgment.diverging_points || []), $json.judgment.reasoning, $json.requires_hitl, $node['ðŸ“ Decision Traceè¨˜éŒ²'].json?.trace_id] }}" }
      },
      "name": "ðŸ’¾ SMåˆ¤å®šçµæžœä¿å­˜",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }},
      "continueOnFail": true
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "requires-hitl", "leftValue": "={{ $json.requires_hitl }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" }}]
        }
      },
      "name": "HitLå¿…è¦ï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO hitl_approval_queue (tenant_id, entity_type, entity_id, entity_data, risk_level, risk_factors, ai_recommendation, ai_confidence, ai_reasoning, auto_approve_if_confidence_above) VALUES ($1, 'sm_reference', $2, $3::jsonb, $4, $5::jsonb, 'review', $6, $7, 90) RETURNING queue_id",
        "options": { "queryParams": "={{ [$json.tenant_id, $json.product_id, JSON.stringify({ judgment: $json.judgment, selected_candidate: $json.selected_candidate, top_candidates: $json.candidate_items?.slice(0, 5) }), $json.judgment.overall_confidence < 50 ? 'high' : 'medium', JSON.stringify([$json.hitl_reason, ...($json.judgment.diverging_points || [])]), $json.judgment.overall_confidence, $json.judgment.reasoning] }}" }
      },
      "name": "ðŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }}
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://api.chatwork.com/v2/rooms/{{ $env.CHATWORK_ROOM_ID }}/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [{ "name": "X-ChatWorkToken", "value": "={{ $env.CHATWORK_API_KEY }}" }]
        },
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [{ "name": "body", "value": "[info][title]ðŸ” SMåˆ¤å®š: äººé–“ç¢ºèªãŒå¿…è¦ã§ã™[/title]å•†å“ID: {{ $json.product_id }}\næ¤œç´¢: {{ $json.search_query }}\nç¢ºä¿¡åº¦: {{ $json.judgment.overall_confidence }}ç‚¹\n\né¸æŠžå€™è£œ: {{ $json.judgment.selected_title || 'åˆ¤å®šä¸èƒ½' }}\nç†ç”±: {{ $json.hitl_reason }}\n\næ‰¿èªURL: {{ $env.N3_ADMIN_URL }}/hitl/sm-reference/{{ $json.product_id }}[/info]" }]
        },
        "options": {}
      },
      "name": "ðŸ“¨ ChatWorké€šçŸ¥",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, status: 'pending_human_review', product_id: $json.product_id, confidence: $json.judgment.overall_confidence, queue_id: $node['ðŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²'].json?.queue_id, message: 'ç¢ºä¿¡åº¦ãŒé–¾å€¤æœªæº€ã®ãŸã‚ã€äººé–“ã«ã‚ˆã‚‹ç¢ºèªãŒå¿…è¦ã§ã™' }) }}",
        "options": { "responseCode": 202 }
      },
      "name": "HitLå¾…ã¡å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE products_master SET sm_reference_id = $1, sm_reference_title = $2, sm_reference_price_usd = $3, sm_confidence_score = $4, sm_strategy = 'auto_approved', sm_strategy_reason = $5, updated_at = NOW() WHERE id = $6",
        "options": { "queryParams": "={{ [$json.judgment.selected_item_id, $json.judgment.selected_title || $json.selected_candidate?.title, $json.selected_candidate?.price, $json.judgment.overall_confidence, 'AIåˆ¤å®šç¢ºä¿¡åº¦' + $json.judgment.overall_confidence + 'ç‚¹ã§è‡ªå‹•æ‰¿èª', $json.product_id] }}" }
      },
      "name": "âœ… products_masteræ›´æ–°",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }},
      "continueOnFail": true
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, status: 'auto_approved', product_id: $json.product_id, selected_reference: { item_id: $json.judgment.selected_item_id, title: $json.judgment.selected_title || $json.selected_candidate?.title, price: $json.selected_candidate?.price }, confidence: $json.judgment.overall_confidence, matching_points: $json.judgment.matching_points, reasoning: $json.judgment.reasoning }) }}",
        "options": { "responseCode": 200 }
      },
      "name": "âœ… è‡ªå‹•æ‰¿èªå¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    }
  ],

  "connections": {
    "Webhook: SM AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ": { "main": [[{ "node": "ðŸ” èªè¨¼ + åˆæœŸåŒ–", "type": "main", "index": 0 }]] },
    "ðŸ” èªè¨¼ + åˆæœŸåŒ–": { "main": [[{ "node": "ã‚¨ãƒ©ãƒ¼ï¼Ÿ", "type": "main", "index": 0 }]] },
    "ã‚¨ãƒ©ãƒ¼ï¼Ÿ": { "main": [[{ "node": "ã‚¨ãƒ©ãƒ¼å¿œç­”", "type": "main", "index": 0 }], [{ "node": "å€™è£œã‚ã‚Šï¼Ÿ", "type": "main", "index": 0 }]] },
    "å€™è£œã‚ã‚Šï¼Ÿ": { "main": [[{ "node": "æ—¢å­˜å€™è£œä½¿ç”¨", "type": "main", "index": 0 }], [{ "node": "ðŸ” eBay Browse APIæ¤œç´¢", "type": "main", "index": 0 }]] },
    "ðŸ” eBay Browse APIæ¤œç´¢": { "main": [[{ "node": "ðŸ“‹ å€™è£œãƒªã‚¹ãƒˆæº–å‚™", "type": "main", "index": 0 }]] },
    "ðŸ“‹ å€™è£œãƒªã‚¹ãƒˆæº–å‚™": { "main": [[{ "node": "ðŸ§  Gemini Pro: ã‚¿ã‚¤ãƒˆãƒ«ãƒ»Specsç…§åˆ", "type": "main", "index": 0 }]] },
    "æ—¢å­˜å€™è£œä½¿ç”¨": { "main": [[{ "node": "ðŸ§  Gemini Pro: ã‚¿ã‚¤ãƒˆãƒ«ãƒ»Specsç…§åˆ", "type": "main", "index": 0 }]] },
    "ðŸ§  Gemini Pro: ã‚¿ã‚¤ãƒˆãƒ«ãƒ»Specsç…§åˆ": { "main": [[{ "node": "ðŸ“Š AIåˆ¤å®šçµæžœãƒ‘ãƒ¼ã‚¹", "type": "main", "index": 0 }]] },
    "ðŸ“Š AIåˆ¤å®šçµæžœãƒ‘ãƒ¼ã‚¹": { "main": [[{ "node": "ç”»åƒã‚ã‚Šï¼Ÿ", "type": "main", "index": 0 }]] },
    "ç”»åƒã‚ã‚Šï¼Ÿ": { "main": [[{ "node": "ðŸ–¼ï¸ Gemini Vision: ç”»åƒæ¯”è¼ƒ", "type": "main", "index": 0 }], [{ "node": "ç”»åƒã‚¹ã‚­ãƒƒãƒ—", "type": "main", "index": 0 }]] },
    "ðŸ–¼ï¸ Gemini Vision: ç”»åƒæ¯”è¼ƒ": { "main": [[{ "node": "ðŸ“Š ã‚¹ã‚³ã‚¢çµ±åˆï¼ˆç”»åƒè¾¼ã¿ï¼‰", "type": "main", "index": 0 }]] },
    "ðŸ“Š ã‚¹ã‚³ã‚¢çµ±åˆï¼ˆç”»åƒè¾¼ã¿ï¼‰": { "main": [[{ "node": "ðŸ“ Decision Traceè¨˜éŒ²", "type": "main", "index": 0 }]] },
    "ç”»åƒã‚¹ã‚­ãƒƒãƒ—": { "main": [[{ "node": "ðŸ“ Decision Traceè¨˜éŒ²", "type": "main", "index": 0 }]] },
    "ðŸ“ Decision Traceè¨˜éŒ²": { "main": [[{ "node": "ðŸ’¾ SMåˆ¤å®šçµæžœä¿å­˜", "type": "main", "index": 0 }]] },
    "ðŸ’¾ SMåˆ¤å®šçµæžœä¿å­˜": { "main": [[{ "node": "HitLå¿…è¦ï¼Ÿ", "type": "main", "index": 0 }]] },
    "HitLå¿…è¦ï¼Ÿ": { "main": [[{ "node": "ðŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²", "type": "main", "index": 0 }], [{ "node": "âœ… products_masteræ›´æ–°", "type": "main", "index": 0 }]] },
    "ðŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²": { "main": [[{ "node": "ðŸ“¨ ChatWorké€šçŸ¥", "type": "main", "index": 0 }]] },
    "ðŸ“¨ ChatWorké€šçŸ¥": { "main": [[{ "node": "HitLå¾…ã¡å¿œç­”", "type": "main", "index": 0 }]] },
    "âœ… products_masteræ›´æ–°": { "main": [[{ "node": "âœ… è‡ªå‹•æ‰¿èªå¿œç­”", "type": "main", "index": 0 }]] }
  },

  "settings": {
    "executionTimeout": 300,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },

  "tags": [
    { "name": "V8.2.1-Autonomous", "color": "#dc143c" },
    { "name": "SM-Agent", "color": "#9b59b6" },
    { "name": "AI-Vision", "color": "#3498db" },
    { "name": "HitL-Enabled", "color": "#f39c12" }
  ],

  "active": false
}
