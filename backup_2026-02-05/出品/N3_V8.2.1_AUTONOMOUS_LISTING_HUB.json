{
  "name": "ã€V8.2.1-AUTONOMOUSã€‘å‡ºå“ãƒãƒ–ãƒ»çµ±åˆãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ãƒ¼",
  "description": "N3 Empire OS V8.2.1-Autonomous: 27æ¬¡å…ƒé˜²è¡›æº–æ‹ ãƒ»ä¾¡æ ¼è¨ˆç®—å¼·åˆ¶çµ±åˆãƒ»AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ»ã‚«ãƒ†ã‚´ãƒªæ æœ€é©åŒ–",
  "_version": "8.2.1-autonomous",
  "_27d_compliance": ["dim3_auth_gate", "dim13_decision_trace", "dim22_cost_limit", "dim5_hitl"],
  
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "v821-listing-hub",
        "options": { "responseMode": "responseNode" }
      },
      "name": "Webhook: V8.2.1å‡ºå“ãƒãƒ–",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "webhookId": "v821-listing-hub"
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ” 27æ¬¡å…ƒ-3: JITãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ï¼ˆAuth-Gateãƒã‚¤ãƒ‘ã‚¹æ’é™¤ï¼‰\n// ============================================================================\nconst body = $input.first().json.body || $input.first().json;\nconst headers = $input.first().json.headers || {};\n\nconst jitToken = headers['x-n3-jit-token'] || headers['X-N3-JIT-Token'];\nconst hmacSignature = headers['x-n3-signature'] || headers['X-N3-Signature'];\nconst timestamp = headers['x-n3-timestamp'] || headers['X-N3-Timestamp'];\n\nif (!jitToken && !hmacSignature) {\n  return [{ json: { \n    error: true, \n    code: 'AUTH_REQUIRED', \n    message: 'èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ãŒå¿…è¦ã§ã™ï¼ˆJIT Token ã¾ãŸã¯ HMACï¼‰',\n    _27d_violation: 'dim3_auth_gate'\n  }}];\n}\n\n// JITãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ï¼ˆå„ªå…ˆï¼‰\nif (jitToken) {\n  try {\n    const validateResponse = await fetch(`${$env.SUPABASE_URL}/rest/v1/rpc/validate_jit_token`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'apikey': $env.SUPABASE_ANON_KEY,\n        'Authorization': `Bearer ${$env.SUPABASE_SERVICE_ROLE_KEY}`\n      },\n      body: JSON.stringify({\n        p_token: jitToken,\n        p_purpose: 'listing',\n        p_required_scope: 'write'\n      })\n    });\n    const result = await validateResponse.json();\n    \n    if (!result.valid) {\n      return [{ json: { \n        error: true, \n        code: 'INVALID_JIT_TOKEN', \n        message: `JITãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼å¤±æ•—: ${result.reason}`,\n        _27d_violation: 'dim3_auth_gate'\n      }}];\n    }\n    \n    // æ¤œè¨¼æˆåŠŸ\n    return [{ json: {\n      ...body,\n      _auth: {\n        method: 'jit_token',\n        tenant_id: result.tenant_id,\n        scope: result.scope,\n        verified_at: new Date().toISOString()\n      }\n    }}];\n  } catch (e) {\n    return [{ json: { error: true, code: 'JIT_VALIDATION_ERROR', message: e.message }}];\n  }\n}\n\n// HMACç½²åæ¤œè¨¼ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰\nconst crypto = require('crypto');\nconst secret = $env.N8N_HMAC_SECRET;\n\nif (!secret) {\n  return [{ json: { error: true, code: 'CONFIG_ERROR', message: 'N8N_HMAC_SECRETæœªè¨­å®š' }}];\n}\n\nif (!timestamp || Math.abs(Date.now() - parseInt(timestamp)) > 300000) {\n  return [{ json: { error: true, code: 'TIMESTAMP_EXPIRED', message: 'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æœŸé™åˆ‡ã‚Œ' }}];\n}\n\nconst computedHmac = crypto.createHmac('sha256', secret).update(timestamp + '.' + JSON.stringify(body)).digest('hex');\nif (hmacSignature !== computedHmac) {\n  return [{ json: { error: true, code: 'HMAC_INVALID', message: 'HMACç½²åæ¤œè¨¼å¤±æ•—' }}];\n}\n\nreturn [{ json: {\n  ...body,\n  _auth: {\n    method: 'hmac',\n    tenant_id: body.user_id || 'default',\n    verified_at: new Date().toISOString()\n  }\n}}];"
      },
      "name": "ğŸ” Auth-Gateï¼ˆ27æ¬¡å…ƒ-3ï¼‰",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "notes": "[27æ¬¡å…ƒ-3] JITãƒˆãƒ¼ã‚¯ãƒ³å„ªå…ˆã€HMACãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯"
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "error-check", "leftValue": "={{ $json.error }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" }}]
        }
      },
      "name": "èªè¨¼ã‚¨ãƒ©ãƒ¼ï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.message, code: $json.code }) }}",
        "options": { "responseCode": 403 }
      },
      "name": "èªè¨¼ã‚¨ãƒ©ãƒ¼å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ’° 27æ¬¡å…ƒ-22: APIç‡ƒç„¼ä¸Šé™ãƒã‚§ãƒƒã‚¯\n// ============================================================================\nconst data = $input.first().json;\nconst tenantId = data._auth?.tenant_id || data.user_id || 'default';\n\n// APIã‚³ã‚¹ãƒˆäº‹å‰ãƒã‚§ãƒƒã‚¯\ntry {\n  const checkResponse = await fetch(`${$env.SUPABASE_URL}/rest/v1/api_consumption_limits?tenant_id=eq.${tenantId}&api_provider=eq.gemini`, {\n    headers: {\n      'apikey': $env.SUPABASE_ANON_KEY,\n      'Authorization': `Bearer ${$env.SUPABASE_SERVICE_ROLE_KEY}`\n    }\n  });\n  const limits = await checkResponse.json();\n  \n  if (limits.length > 0 && limits[0].is_blocked) {\n    return [{ json: {\n      error: true,\n      code: 'COST_LIMIT_EXCEEDED',\n      message: `APIç‡ƒç„¼ä¸Šé™åˆ°é”: ${limits[0].blocked_reason}`,\n      _27d_violation: 'dim22_cost_limit',\n      daily_used: limits[0].daily_used_usd,\n      daily_limit: limits[0].daily_limit_usd\n    }}];\n  }\n} catch (e) {\n  // ãƒã‚§ãƒƒã‚¯å¤±æ•—ã¯è­¦å‘Šã®ã¿ã§ç¶šè¡Œ\n  console.log('Cost limit check warning:', e.message);\n}\n\nreturn [{ json: { ...data, _cost_check: { passed: true, checked_at: new Date().toISOString() } }}];"
      },
      "name": "ğŸ’° ç‡ƒç„¼ä¸Šé™ãƒã‚§ãƒƒã‚¯ï¼ˆ27æ¬¡å…ƒ-22ï¼‰",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "notes": "[27æ¬¡å…ƒ-22] APIæ¶ˆè²»ã‚³ã‚¹ãƒˆæ—¥æ¬¡/æœˆæ¬¡ä¸Šé™ãƒã‚§ãƒƒã‚¯"
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "cost-error", "leftValue": "={{ $json.error }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" }}]
        }
      },
      "name": "ç‡ƒç„¼ä¸Šé™è¶…éï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.message, code: $json.code, _27d_violation: $json._27d_violation }) }}",
        "options": { "responseCode": 429 }
      },
      "name": "ç‡ƒç„¼ä¸Šé™ã‚¨ãƒ©ãƒ¼å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT pm.id, pm.sku, pm.title, pm.title_en, pm.product_name, pm.description, pm.description_en, pm.image_urls, pm.listing_price, pm.item_specifics, pm.ebay_category_id, pm.sm_confidence_score, pm.updated_at, im.purchase_price, im.purchase_currency, im.weight_grams, im.dimension_cm_l, im.dimension_cm_w, im.dimension_cm_h, im.physical_quantity, COALESCE(im.packaging_cost, 200) as packaging_cost FROM products_master pm LEFT JOIN inventory_master im ON im.product_master_id = pm.id WHERE pm.id = $1 AND (pm.user_id = $2 OR pm.user_id IS NULL) LIMIT 1",
        "options": { "queryParams": "={{ [$json.product_id, $json._auth?.tenant_id || $json.user_id || 'default'] }}" }
      },
      "name": "ğŸ“¦ å•†å“æƒ…å ±å–å¾—",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }}
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ”— å¤šè²©è·¯ä¾¡æ ¼è¨ˆç®—å¼·åˆ¶å‘¼ã³å‡ºã—\n// ============================================================================\nconst prevData = $node['ğŸ’° ç‡ƒç„¼ä¸Šé™ãƒã‚§ãƒƒã‚¯ï¼ˆ27æ¬¡å…ƒ-22ï¼‰'].json;\nconst productArr = Array.isArray($input.first().json) ? $input.first().json : [$input.first().json];\nconst product = productArr[0];\n\nif (!product || !product.id) {\n  return [{ json: { error: true, code: 'PRODUCT_NOT_FOUND', message: 'å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' }}];\n}\n\nconst tenantId = prevData._auth?.tenant_id || prevData.user_id || 'default';\nconst targetMarketplaces = prevData.target_marketplaces || ['ebay_us', 'qoo10_jp', 'amazon_us'];\n\n// ä¾¡æ ¼è¨ˆç®—APIå‘¼ã³å‡ºã—\nconst calcPayload = {\n  product_id: product.id,\n  user_id: tenantId,\n  target_marketplaces: targetMarketplaces,\n  target_margin: prevData.target_margin || 15,\n  enable_media_queue: false\n};\n\ntry {\n  const timestamp = Date.now().toString();\n  const crypto = require('crypto');\n  const signature = crypto.createHmac('sha256', $env.N8N_HMAC_SECRET || '')\n    .update(timestamp + '.' + JSON.stringify(calcPayload))\n    .digest('hex');\n  \n  const calcResponse = await fetch(`${$env.N8N_BASE_URL || $env.N8N_WEBHOOK_URL}/webhook/multi-marketplace-calculate`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'x-n3-signature': signature,\n      'x-n3-timestamp': timestamp\n    },\n    body: JSON.stringify(calcPayload)\n  });\n  \n  const calcResult = await calcResponse.json();\n  \n  if (!calcResult.success) {\n    return [{ json: {\n      error: true,\n      code: 'PRICE_CALC_FAILED',\n      message: 'ä¾¡æ ¼è¨ˆç®—å¤±æ•—: ' + (calcResult.error || 'Unknown'),\n      product_id: product.id\n    }}];\n  }\n  \n  // åˆ©ç›ŠãŒå‡ºã‚‹è²©è·¯ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿\n  const profitableMarkets = (calcResult.calculations || []).filter(c => c.is_profitable === 1);\n  \n  if (profitableMarkets.length === 0) {\n    return [{ json: {\n      error: true,\n      code: 'NO_PROFITABLE_MARKET',\n      message: 'å…¨ã¦ã®è²©è·¯ã§åˆ©ç›ŠåŸºæº–ï¼ˆ5%ä»¥ä¸Šï¼‰ã‚’æº€ãŸã—ã¾ã›ã‚“',\n      product_id: product.id,\n      calculations: calcResult.calculations\n    }}];\n  }\n  \n  return [{ json: {\n    ...prevData,\n    product: product,\n    price_calculations: calcResult.calculations,\n    profitable_markets: profitableMarkets,\n    _price_calc: {\n      success: true,\n      total_markets: targetMarketplaces.length,\n      profitable_count: profitableMarkets.length,\n      calculated_at: calcResult.calculated_at\n    }\n  }}];\n  \n} catch (e) {\n  return [{ json: {\n    error: true,\n    code: 'PRICE_CALC_ERROR',\n    message: 'ä¾¡æ ¼è¨ˆç®—APIã‚¨ãƒ©ãƒ¼: ' + e.message,\n    product_id: product.id\n  }}];\n}"
      },
      "name": "ğŸ”— ä¾¡æ ¼è¨ˆç®—å¼·åˆ¶çµ±åˆ",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "notes": "[CRITICAL] å‡ºå“å‰ã«å¿…ãš multi-marketplace-calculate ã‚’å‘¼ã³å‡ºã—"
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "calc-error", "leftValue": "={{ $json.error }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" }}]
        }
      },
      "name": "ä¾¡æ ¼è¨ˆç®—ã‚¨ãƒ©ãƒ¼ï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.message, code: $json.code, calculations: $json.calculations }) }}",
        "options": { "responseCode": 400 }
      },
      "name": "ä¾¡æ ¼è¨ˆç®—ã‚¨ãƒ©ãƒ¼å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ“Š ã‚«ãƒ†ã‚´ãƒªæ æœ€é©åŒ–ï¼ˆãƒŠãƒƒãƒ—ã‚µãƒƒã‚¯è¿‘ä¼¼è§£æ³•ï¼‰\n// ============================================================================\nconst data = $input.first().json;\nconst tenantId = data._auth?.tenant_id || data.user_id || 'default';\nconst product = data.product;\nconst profitableMarkets = data.profitable_markets || [];\n\n// åˆ©ç›ŠæœŸå¾…å€¤è¨ˆç®—\nconst expectedValue = profitableMarkets.reduce((sum, m) => {\n  const sellProbability = 0.5;  // TODO: å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç®—å‡º\n  return sum + (m.profit_jpy * sellProbability);\n}, 0);\n\n// æ å‰²ã‚Šå½“ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆ\ntry {\n  const optimizeResponse = await fetch(`${$env.SUPABASE_URL}/rest/v1/rpc/optimize_slot_allocation`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': $env.SUPABASE_ANON_KEY,\n      'Authorization': `Bearer ${$env.SUPABASE_SERVICE_ROLE_KEY}`\n    },\n    body: JSON.stringify({\n      p_tenant_id: tenantId,\n      p_products: JSON.stringify([{\n        id: product.id,\n        category_id: product.ebay_category_id || 'default',\n        profit_margin: profitableMarkets[0]?.profit_rate / 100 || 0.15,\n        sell_probability: 0.5,\n        price_usd: profitableMarkets.find(m => m.currency === 'USD')?.selling_price || 50\n      }]),\n      p_max_allocations: 1\n    })\n  });\n  \n  const slotResult = await optimizeResponse.json();\n  \n  if (!slotResult.success || slotResult.assigned_count === 0) {\n    // æ ãªã— â†’ å¤œé–“ã‚·ãƒ•ãƒˆã‚­ãƒ¥ãƒ¼ã¸\n    return [{ json: {\n      ...data,\n      _slot_allocation: {\n        success: false,\n        reason: 'no_available_slot',\n        action: 'queue_night_shift'\n      }\n    }}];\n  }\n  \n  const assignment = slotResult.assignments[0];\n  \n  return [{ json: {\n    ...data,\n    _slot_allocation: {\n      success: true,\n      account_id: assignment.account_id,\n      category_id: assignment.category_id,\n      expected_value: assignment.expected_value,\n      priority: assignment.priority\n    }\n  }}];\n  \n} catch (e) {\n  // æ ãƒã‚§ãƒƒã‚¯å¤±æ•—ã¯è­¦å‘Šã§ç¶šè¡Œï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½¿ç”¨ï¼‰\n  return [{ json: {\n    ...data,\n    _slot_allocation: {\n      success: false,\n      reason: 'check_failed',\n      error: e.message,\n      action: 'use_default_account'\n    }\n  }}];\n}"
      },
      "name": "ğŸ“Š æ ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "notes": "[V8.2.1] ã‚«ãƒ†ã‚´ãƒªæ æœ€é©åŒ–ã€‚æ ãªã—ãªã‚‰å¤œé–“ã‚·ãƒ•ãƒˆã‚­ãƒ¥ãƒ¼ã¸"
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "no-slot", "leftValue": "={{ $json._slot_allocation?.action }}", "rightValue": "queue_night_shift", "operator": { "type": "string", "operation": "equals" }}]
        }
      },
      "name": "æ ãªã—ï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO async_task_queue (tenant_id, task_type, priority, payload, night_shift_only, scheduled_at) VALUES ($1, 'listing', 5, $2::jsonb, true, NOW() + INTERVAL '1 hour') RETURNING task_id",
        "options": { "queryParams": "={{ [$json._auth?.tenant_id || $json.user_id, JSON.stringify({ product_id: $json.product?.id, target_marketplaces: $json.profitable_markets?.map(m => m.marketplace) })] }}" }
      },
      "name": "ğŸŒ™ å¤œé–“ã‚·ãƒ•ãƒˆã‚­ãƒ¥ãƒ¼ç™»éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }},
      "continueOnFail": true
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, action: 'queued_night_shift', message: 'æ ç©ºãå¾…ã¡ã€‚å¤œé–“ã‚·ãƒ•ãƒˆã§å‡¦ç†äºˆå®š', task_id: $json.task_id }) }}",
        "options": { "responseCode": 202 }
      },
      "name": "å¤œé–“ã‚·ãƒ•ãƒˆå¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Content-Type", "value": "application/json" },
            { "name": "x-goog-api-key", "value": "={{ $env.GEMINI_API_KEY }}" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ contents: [{ parts: [{ text: '## å¤šè²©è·¯ã‚¿ã‚¤ãƒˆãƒ«æœ€é©åŒ–\\n\\nå•†å“å: ' + ($json.product?.title || $json.product?.product_name || '') + '\\nèª¬æ˜: ' + ($json.product?.description || '').substring(0, 500) + '\\n\\nä»¥ä¸‹ã®JSONã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:\\n{\\n  \"ebay_title\": \"è‹±èª80æ–‡å­—ä»¥å†…\",\\n  \"qoo10_title\": \"æ—¥æœ¬èª100æ–‡å­—ä»¥å†…\",\\n  \"amazon_title\": \"è‹±èª200æ–‡å­—ä»¥å†…\",\\n  \"reasoning\": \"ã‚¿ã‚¤ãƒˆãƒ«æœ€é©åŒ–ã®ç†ç”±\"\\n}' }] }], generationConfig: { temperature: 0.3, maxOutputTokens: 1024 } }) }}",
        "options": { "timeout": 30000 }
      },
      "name": "ğŸ§  Gemini: ã‚¿ã‚¤ãƒˆãƒ«æœ€é©åŒ–",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ“ 27æ¬¡å…ƒ-13: Decision Traceï¼ˆAIåˆ¤æ–­è¨¼è·¡ï¼‰è¨˜éŒ²\n// ============================================================================\nconst prevData = $node['ğŸ“Š æ ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼'].json;\nconst aiResponse = $input.first().json;\nconst tenantId = prevData._auth?.tenant_id || prevData.user_id || 'default';\n\n// AIãƒ¬ã‚¹ãƒãƒ³ã‚¹è§£æ\nlet optimized = { ebay_title: '', qoo10_title: '', amazon_title: '', reasoning: '' };\ntry {\n  const text = aiResponse.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n  const match = text.match(/\\{[\\s\\S]*\\}/);\n  if (match) optimized = JSON.parse(match[0]);\n} catch (e) {\n  optimized.reasoning = 'AIè§£æå¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒˆãƒ«ä½¿ç”¨';\n}\n\n// Decision Traceè¨˜éŒ²\ntry {\n  await fetch(`${$env.SUPABASE_URL}/rest/v1/ai_decision_traces`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'apikey': $env.SUPABASE_ANON_KEY,\n      'Authorization': `Bearer ${$env.SUPABASE_SERVICE_ROLE_KEY}`,\n      'Prefer': 'return=minimal'\n    },\n    body: JSON.stringify({\n      tenant_id: tenantId,\n      workflow_id: $workflow.id,\n      workflow_name: $workflow.name,\n      decision_point: 'title_optimization',\n      input_data: { product_title: prevData.product?.title, product_id: prevData.product?.id },\n      ai_model: 'gemini-1.5-flash',\n      ai_prompt_hash: require('crypto').createHash('sha256').update('title_optimization_v1').digest('hex').substring(0, 16),\n      ai_response: optimized,\n      reasoning: optimized.reasoning || 'ã‚¿ã‚¤ãƒˆãƒ«æœ€é©åŒ–å®Œäº†',\n      confidence_score: optimized.reasoning?.includes('å¤±æ•—') ? 30 : 85,\n      decision_outcome: 'approved'\n    })\n  });\n} catch (e) {\n  console.log('Decision trace save warning:', e.message);\n}\n\nreturn [{ json: {\n  ...prevData,\n  optimized_titles: optimized,\n  _decision_trace: {\n    recorded: true,\n    decision_point: 'title_optimization',\n    confidence: optimized.reasoning?.includes('å¤±æ•—') ? 30 : 85\n  }\n}}];"
      },
      "name": "ğŸ“ Decision Traceè¨˜éŒ²ï¼ˆ27æ¬¡å…ƒ-13ï¼‰",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "notes": "[27æ¬¡å…ƒ-13] AIåˆ¤æ–­ã®è¨¼è·¡ã‚’å…¨ä»¶è¨˜éŒ²"
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ›¡ï¸ èµ¤å­—çµ¶å¯¾å›é¿ã‚¬ãƒ¼ãƒ‡ã‚£ã‚¢ãƒ³ + HitLåˆ¤å®š\n// ============================================================================\nconst data = $input.first().json;\nconst profitableMarkets = data.profitable_markets || [];\nconst tenantId = data._auth?.tenant_id || data.user_id || 'default';\n\n// æœ€ä½åˆ©ç›Šç‡ãƒã‚§ãƒƒã‚¯ï¼ˆå†ç¢ºèªï¼‰\nconst minMargin = Math.min(...profitableMarkets.map(m => m.profit_rate));\nconst avgMargin = profitableMarkets.reduce((sum, m) => sum + m.profit_rate, 0) / profitableMarkets.length;\n\n// ãƒªã‚¹ã‚¯è©•ä¾¡\nlet riskLevel = 'low';\nlet riskFactors = [];\nlet requiresHitL = false;\n\nif (minMargin < 8) {\n  riskLevel = 'medium';\n  riskFactors.push(`ä½åˆ©ç›Šç‡è²©è·¯ã‚ã‚Š (${minMargin.toFixed(1)}%)`);\n}\n\nif (avgMargin < 10) {\n  riskLevel = 'high';\n  riskFactors.push(`å¹³å‡åˆ©ç›Šç‡ä½ã„ (${avgMargin.toFixed(1)}%)`);\n  requiresHitL = true;\n}\n\nif (data.product?.sm_confidence_score && data.product.sm_confidence_score < 70) {\n  riskLevel = 'high';\n  riskFactors.push(`SMä¿¡é ¼åº¦ä½ã„ (${data.product.sm_confidence_score}ç‚¹)`);\n  requiresHitL = true;\n}\n\n// é«˜é¡å•†å“ãƒã‚§ãƒƒã‚¯\nconst maxPrice = Math.max(...profitableMarkets.map(m => m.selling_price_jpy || 0));\nif (maxPrice > 50000) {\n  riskLevel = 'high';\n  riskFactors.push(`é«˜é¡å•†å“ (Â¥${maxPrice.toLocaleString()})`);\n  requiresHitL = true;\n}\n\nreturn [{ json: {\n  ...data,\n  _risk_assessment: {\n    risk_level: riskLevel,\n    risk_factors: riskFactors,\n    min_margin: minMargin,\n    avg_margin: avgMargin,\n    max_price_jpy: maxPrice,\n    requires_hitl: requiresHitL\n  }\n}}];"
      },
      "name": "ğŸ›¡ï¸ ãƒªã‚¹ã‚¯è©•ä¾¡ + HitLåˆ¤å®š",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "notes": "[27æ¬¡å…ƒ-5] é«˜ãƒªã‚¹ã‚¯æ“ä½œã¯äººé–“æ‰¿èªå¿…é ˆ"
    },

    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{ "id": "requires-hitl", "leftValue": "={{ $json._risk_assessment?.requires_hitl }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" }}]
        }
      },
      "name": "HitLå¿…è¦ï¼Ÿ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO hitl_approval_queue (tenant_id, entity_type, entity_id, entity_data, risk_level, risk_factors, ai_recommendation, ai_confidence, ai_reasoning, auto_approve_if_confidence_above, expires_at) VALUES ($1, 'listing', $2, $3::jsonb, $4, $5::jsonb, 'approve', $6, $7, 95, NOW() + INTERVAL '24 hours') RETURNING queue_id",
        "options": { "queryParams": "={{ [$json._auth?.tenant_id || $json.user_id, $json.product?.id, JSON.stringify({ product_sku: $json.product?.sku, profitable_markets: $json.profitable_markets, optimized_titles: $json.optimized_titles }), $json._risk_assessment?.risk_level, JSON.stringify($json._risk_assessment?.risk_factors || []), $json._decision_trace?.confidence || 70, 'ãƒªã‚¹ã‚¯è¦å› : ' + ($json._risk_assessment?.risk_factors || []).join(', ')] }}" }
      },
      "name": "ğŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }}
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, action: 'pending_approval', queue_id: $json.queue_id, risk_level: $node['ğŸ›¡ï¸ ãƒªã‚¹ã‚¯è©•ä¾¡ + HitLåˆ¤å®š'].json._risk_assessment?.risk_level, risk_factors: $node['ğŸ›¡ï¸ ãƒªã‚¹ã‚¯è©•ä¾¡ + HitLåˆ¤å®š'].json._risk_assessment?.risk_factors, message: 'äººé–“ã«ã‚ˆã‚‹æ‰¿èªãŒå¿…è¦ã§ã™' }) }}",
        "options": { "responseCode": 202 }
      },
      "name": "HitLå¾…ã¡å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    },

    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.profitable_markets?.[0]?.marketplace?.split('_')[0] || 'ebay' }}",
        "rules": {
          "rules": [
            { "value2": "ebay", "output": 0 },
            { "value2": "qoo10", "output": 1 },
            { "value2": "amazon", "output": 2 },
            { "value2": "shopee", "output": 3 }
          ]
        },
        "fallbackOutput": 4
      },
      "name": "è²©è·¯åˆ†å²",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3
    },

    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_URL || $env.N8N_BASE_URL + '/webhook' }}/ebay-listing",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "x-n3-signature", "value": "={{ require('crypto').createHmac('sha256', $env.N8N_HMAC_SECRET || '').update(Date.now() + '.' + JSON.stringify({ product_id: $json.product?.id, user_id: $json._auth?.tenant_id, price: $json.profitable_markets?.find(m => m.marketplace?.startsWith('ebay'))?.selling_price })).digest('hex') }}" },
            { "name": "x-n3-timestamp", "value": "={{ Date.now().toString() }}" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ product_id: $json.product?.id, user_id: $json._auth?.tenant_id || $json.user_id, title: $json.optimized_titles?.ebay_title || $json.product?.title_en || $json.product?.title, price: $json.profitable_markets?.find(m => m.marketplace?.startsWith('ebay'))?.selling_price, account_id: $json._slot_allocation?.account_id }) }}",
        "options": { "timeout": 120000 }
      },
      "name": "eBayå‡ºå“å®Ÿè¡Œ",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_URL || $env.N8N_BASE_URL + '/webhook' }}/qoo10-listing",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "x-n3-signature", "value": "={{ require('crypto').createHmac('sha256', $env.N8N_HMAC_SECRET || '').update(Date.now() + '.' + JSON.stringify({ product_id: $json.product?.id, user_id: $json._auth?.tenant_id })).digest('hex') }}" },
            { "name": "x-n3-timestamp", "value": "={{ Date.now().toString() }}" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ product_id: $json.product?.id, user_id: $json._auth?.tenant_id || $json.user_id, title: $json.optimized_titles?.qoo10_title || $json.product?.title, price: $json.profitable_markets?.find(m => m.marketplace === 'qoo10_jp')?.selling_price }) }}",
        "options": { "timeout": 120000 }
      },
      "name": "Qoo10å‡ºå“å®Ÿè¡Œ",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_URL || $env.N8N_BASE_URL + '/webhook' }}/amazon-listing",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "x-n3-signature", "value": "={{ require('crypto').createHmac('sha256', $env.N8N_HMAC_SECRET || '').update(Date.now() + '.' + JSON.stringify({ product_id: $json.product?.id, user_id: $json._auth?.tenant_id })).digest('hex') }}" },
            { "name": "x-n3-timestamp", "value": "={{ Date.now().toString() }}" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ product_id: $json.product?.id, user_id: $json._auth?.tenant_id || $json.user_id, title: $json.optimized_titles?.amazon_title || $json.product?.title_en, price: $json.profitable_markets?.find(m => m.marketplace?.startsWith('amazon'))?.selling_price }) }}",
        "options": { "timeout": 120000 }
      },
      "name": "Amazonå‡ºå“å®Ÿè¡Œ",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "jsCode": "return [{ json: { error: true, code: 'SHOPEE_NOT_IMPLEMENTED', message: 'Shopeeå‡ºå“ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã¯æœªå®Ÿè£…' }}];"
      },
      "name": "Shopeeï¼ˆæœªå®Ÿè£…ï¼‰",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "jsCode": "return [{ json: { error: true, code: 'UNKNOWN_MARKETPLACE', message: 'æœªå¯¾å¿œã®è²©è·¯ã§ã™' }}];"
      },
      "name": "æœªå¯¾å¿œè²©è·¯",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "jsCode": "// ============================================================================\n// ğŸ“Š çµæœé›†ç´„\n// ============================================================================\nconst result = $input.first().json;\nconst prevData = $node['ğŸ›¡ï¸ ãƒªã‚¹ã‚¯è©•ä¾¡ + HitLåˆ¤å®š'].json;\n\nconst success = !result.error && (result.success || result.ItemID || result.status === 'success');\n\nreturn [{ json: {\n  success: success,\n  product_id: prevData.product?.id,\n  product_sku: prevData.product?.sku,\n  marketplace: prevData.profitable_markets?.[0]?.marketplace,\n  selling_price: prevData.profitable_markets?.[0]?.selling_price,\n  profit_rate: prevData.profitable_markets?.[0]?.profit_rate,\n  account_id: prevData._slot_allocation?.account_id,\n  risk_level: prevData._risk_assessment?.risk_level,\n  listing_result: result,\n  _traces: {\n    auth: prevData._auth,\n    price_calc: prevData._price_calc,\n    slot_allocation: prevData._slot_allocation,\n    decision_trace: prevData._decision_trace\n  }\n}}];"
      },
      "name": "ğŸ“Š çµæœé›†ç´„",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO listing_history (user_id, product_id, target_mall, status, result_json, created_at) VALUES ($1, $2, $3, $4, $5::jsonb, NOW())",
        "options": { "queryParams": "={{ [$json._traces?.auth?.tenant_id || 'default', $json.product_id, $json.marketplace, $json.success ? 'success' : 'failed', JSON.stringify({ success: $json.success, price: $json.selling_price, profit_rate: $json.profit_rate, account_id: $json.account_id })] }}" }
      },
      "name": "ğŸ’¾ å‡ºå“å±¥æ­´è¨˜éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" }},
      "continueOnFail": true
    },

    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.SUPABASE_URL}}/rest/v1/execution_logs",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "apikey", "value": "={{$env.SUPABASE_ANON_KEY}}" },
            { "name": "Authorization", "value": "=Bearer {{$env.SUPABASE_SERVICE_ROLE_KEY}}" },
            { "name": "Content-Type", "value": "application/json" },
            { "name": "Prefer", "value": "return=minimal" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflow_id\": \"{{$workflow.id}}\",\n  \"workflow_name\": \"{{$workflow.name}}\",\n  \"status\": \"{{ $json.success ? 'success' : 'failed' }}\",\n  \"execution_time_ms\": {{Date.now() - $execution.startedAt.getTime()}},\n  \"error_message\": {{ $json.success ? 'null' : JSON.stringify($json.listing_result?.error || 'Unknown') }},\n  \"executed_at\": \"{{new Date().toISOString()}}\",\n  \"node_count\": {{$workflow.nodes.length}},\n  \"metadata\": { \"product_id\": \"{{ $json.product_id }}\", \"marketplace\": \"{{ $json.marketplace }}\" }\n}"
      },
      "name": "ğŸ“Š å®Ÿè¡Œãƒ­ã‚°é€ä¿¡",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "continueOnFail": true
    },

    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": { "responseCode": "={{ $json.success ? 200 : 400 }}" }
      },
      "name": "âœ… æœ€çµ‚å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1
    }
  ],

  "connections": {
    "Webhook: V8.2.1å‡ºå“ãƒãƒ–": { "main": [[{ "node": "ğŸ” Auth-Gateï¼ˆ27æ¬¡å…ƒ-3ï¼‰", "type": "main", "index": 0 }]] },
    "ğŸ” Auth-Gateï¼ˆ27æ¬¡å…ƒ-3ï¼‰": { "main": [[{ "node": "èªè¨¼ã‚¨ãƒ©ãƒ¼ï¼Ÿ", "type": "main", "index": 0 }]] },
    "èªè¨¼ã‚¨ãƒ©ãƒ¼ï¼Ÿ": { "main": [[{ "node": "èªè¨¼ã‚¨ãƒ©ãƒ¼å¿œç­”", "type": "main", "index": 0 }], [{ "node": "ğŸ’° ç‡ƒç„¼ä¸Šé™ãƒã‚§ãƒƒã‚¯ï¼ˆ27æ¬¡å…ƒ-22ï¼‰", "type": "main", "index": 0 }]] },
    "ğŸ’° ç‡ƒç„¼ä¸Šé™ãƒã‚§ãƒƒã‚¯ï¼ˆ27æ¬¡å…ƒ-22ï¼‰": { "main": [[{ "node": "ç‡ƒç„¼ä¸Šé™è¶…éï¼Ÿ", "type": "main", "index": 0 }]] },
    "ç‡ƒç„¼ä¸Šé™è¶…éï¼Ÿ": { "main": [[{ "node": "ç‡ƒç„¼ä¸Šé™ã‚¨ãƒ©ãƒ¼å¿œç­”", "type": "main", "index": 0 }], [{ "node": "ğŸ“¦ å•†å“æƒ…å ±å–å¾—", "type": "main", "index": 0 }]] },
    "ğŸ“¦ å•†å“æƒ…å ±å–å¾—": { "main": [[{ "node": "ğŸ”— ä¾¡æ ¼è¨ˆç®—å¼·åˆ¶çµ±åˆ", "type": "main", "index": 0 }]] },
    "ğŸ”— ä¾¡æ ¼è¨ˆç®—å¼·åˆ¶çµ±åˆ": { "main": [[{ "node": "ä¾¡æ ¼è¨ˆç®—ã‚¨ãƒ©ãƒ¼ï¼Ÿ", "type": "main", "index": 0 }]] },
    "ä¾¡æ ¼è¨ˆç®—ã‚¨ãƒ©ãƒ¼ï¼Ÿ": { "main": [[{ "node": "ä¾¡æ ¼è¨ˆç®—ã‚¨ãƒ©ãƒ¼å¿œç­”", "type": "main", "index": 0 }], [{ "node": "ğŸ“Š æ ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼", "type": "main", "index": 0 }]] },
    "ğŸ“Š æ ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼": { "main": [[{ "node": "æ ãªã—ï¼Ÿ", "type": "main", "index": 0 }]] },
    "æ ãªã—ï¼Ÿ": { "main": [[{ "node": "ğŸŒ™ å¤œé–“ã‚·ãƒ•ãƒˆã‚­ãƒ¥ãƒ¼ç™»éŒ²", "type": "main", "index": 0 }], [{ "node": "ğŸ§  Gemini: ã‚¿ã‚¤ãƒˆãƒ«æœ€é©åŒ–", "type": "main", "index": 0 }]] },
    "ğŸŒ™ å¤œé–“ã‚·ãƒ•ãƒˆã‚­ãƒ¥ãƒ¼ç™»éŒ²": { "main": [[{ "node": "å¤œé–“ã‚·ãƒ•ãƒˆå¿œç­”", "type": "main", "index": 0 }]] },
    "ğŸ§  Gemini: ã‚¿ã‚¤ãƒˆãƒ«æœ€é©åŒ–": { "main": [[{ "node": "ğŸ“ Decision Traceè¨˜éŒ²ï¼ˆ27æ¬¡å…ƒ-13ï¼‰", "type": "main", "index": 0 }]] },
    "ğŸ“ Decision Traceè¨˜éŒ²ï¼ˆ27æ¬¡å…ƒ-13ï¼‰": { "main": [[{ "node": "ğŸ›¡ï¸ ãƒªã‚¹ã‚¯è©•ä¾¡ + HitLåˆ¤å®š", "type": "main", "index": 0 }]] },
    "ğŸ›¡ï¸ ãƒªã‚¹ã‚¯è©•ä¾¡ + HitLåˆ¤å®š": { "main": [[{ "node": "HitLå¿…è¦ï¼Ÿ", "type": "main", "index": 0 }]] },
    "HitLå¿…è¦ï¼Ÿ": { "main": [[{ "node": "ğŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²", "type": "main", "index": 0 }], [{ "node": "è²©è·¯åˆ†å²", "type": "main", "index": 0 }]] },
    "ğŸ“‹ HitLã‚­ãƒ¥ãƒ¼ç™»éŒ²": { "main": [[{ "node": "HitLå¾…ã¡å¿œç­”", "type": "main", "index": 0 }]] },
    "è²©è·¯åˆ†å²": { "main": [[{ "node": "eBayå‡ºå“å®Ÿè¡Œ", "type": "main", "index": 0 }], [{ "node": "Qoo10å‡ºå“å®Ÿè¡Œ", "type": "main", "index": 0 }], [{ "node": "Amazonå‡ºå“å®Ÿè¡Œ", "type": "main", "index": 0 }], [{ "node": "Shopeeï¼ˆæœªå®Ÿè£…ï¼‰", "type": "main", "index": 0 }], [{ "node": "æœªå¯¾å¿œè²©è·¯", "type": "main", "index": 0 }]] },
    "eBayå‡ºå“å®Ÿè¡Œ": { "main": [[{ "node": "ğŸ“Š çµæœé›†ç´„", "type": "main", "index": 0 }]] },
    "Qoo10å‡ºå“å®Ÿè¡Œ": { "main": [[{ "node": "ğŸ“Š çµæœé›†ç´„", "type": "main", "index": 0 }]] },
    "Amazonå‡ºå“å®Ÿè¡Œ": { "main": [[{ "node": "ğŸ“Š çµæœé›†ç´„", "type": "main", "index": 0 }]] },
    "Shopeeï¼ˆæœªå®Ÿè£…ï¼‰": { "main": [[{ "node": "ğŸ“Š çµæœé›†ç´„", "type": "main", "index": 0 }]] },
    "æœªå¯¾å¿œè²©è·¯": { "main": [[{ "node": "ğŸ“Š çµæœé›†ç´„", "type": "main", "index": 0 }]] },
    "ğŸ“Š çµæœé›†ç´„": { "main": [[{ "node": "ğŸ’¾ å‡ºå“å±¥æ­´è¨˜éŒ²", "type": "main", "index": 0 }]] },
    "ğŸ’¾ å‡ºå“å±¥æ­´è¨˜éŒ²": { "main": [[{ "node": "ğŸ“Š å®Ÿè¡Œãƒ­ã‚°é€ä¿¡", "type": "main", "index": 0 }]] },
    "ğŸ“Š å®Ÿè¡Œãƒ­ã‚°é€ä¿¡": { "main": [[{ "node": "âœ… æœ€çµ‚å¿œç­”", "type": "main", "index": 0 }]] }
  },

  "settings": {
    "executionTimeout": 600,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },

  "tags": [
    { "name": "V8.2.1-Autonomous", "color": "#dc143c" },
    { "name": "27D-Compliant", "color": "#ffd700" },
    { "name": "Price-Calc-Integrated", "color": "#32cd32" },
    { "name": "Slot-Optimizer", "color": "#9b59b6" },
    { "name": "HitL-Enabled", "color": "#3498db" }
  ],

  "active": false
}
