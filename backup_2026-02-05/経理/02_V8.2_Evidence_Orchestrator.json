{
  "name": "ã€V8.2ã€‘Evidence Orchestrator - è¨¼è·¡è‡ªå‹•é›†ç´„ã‚¨ãƒ³ã‚¸ãƒ³",
  "description": "N3 Empire OS V8.2: å–å¼•ã«é–¢ã‚ã‚‹å…¨ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã‚’è‡ªå‹•é›†ç´„ã—ã€è­¦å¯Ÿï¼ˆå¤ç‰©å°å¸³ï¼‰ãƒ»ç¨å‹™ç½²ï¼ˆçµŒè²»ç²¾ç®—ï¼‰æ§˜å¼ã®PDFã‚’å‡ºåŠ›ã™ã‚‹",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "evidence-orchestrator",
        "options": { "responseMode": "responseNode" }
      },
      "id": "webhook-entry",
      "name": "ğŸšª Webhook Entry",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "webhookId": "evidence-orchestrator",
      "position": [220, 300]
    },
    {
      "parameters": {
        "jsCode": "// V8.2 AUTH-GATE\nconst crypto = require('crypto');\nconst body = $input.first().json.body || $input.first().json || {};\nconst headers = $input.first().json.headers || {};\nconst tenantId = body.tenant_id || headers['x-tenant-id'] || 'default';\nconst signature = headers['x-n3-signature'];\nconst timestamp = headers['x-n3-timestamp'];\nconst hmacSecret = $env.N8N_HMAC_SECRET;\n\nif (hmacSecret && signature && timestamp) {\n  const tsAge = Date.now() - parseInt(timestamp);\n  if (tsAge > 300000) return [{ json: { _auth_error: true, code: 'TIMESTAMP_EXPIRED' } }];\n  const expectedHmac = crypto.createHmac('sha256', hmacSecret).update(timestamp + '.' + JSON.stringify(body)).digest('hex');\n  if (signature !== expectedHmac) return [{ json: { _auth_error: true, code: 'HMAC_INVALID' } }];\n}\n\nreturn [{ json: { _auth_passed: true, _tenant_id: tenantId, _request_id: `evid-${Date.now()}-${Math.random().toString(36).substr(2,9)}`, _timestamp: new Date().toISOString(), payload: body } }];"
      },
      "id": "auth-gate",
      "name": "ğŸ” V8.2 Auth-Gate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true },
          "conditions": [{ "leftValue": "={{ $json._auth_error }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" } }]
        }
      },
      "id": "auth-check",
      "name": "èªè¨¼ãƒã‚§ãƒƒã‚¯",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'Authentication failed' }) }}",
        "options": { "responseCode": 401 }
      },
      "id": "auth-error",
      "name": "âŒ èªè¨¼ã‚¨ãƒ©ãƒ¼",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 200]
    },
    {
      "parameters": {
        "jsCode": "// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²\nconst data = $input.first().json;\nconst action = data.payload?.action || 'collect';\nconst validActions = ['collect', 'generate_pdf', 'reconcile', 'archive'];\nif (!validActions.includes(action)) {\n  return [{ json: { ...data, _action: 'error', _error: `Invalid action: ${action}` } }];\n}\nreturn [{ json: { ...data, _action: action } }];"
      },
      "id": "action-router",
      "name": "ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 400]
    },
    {
      "parameters": {
        "rules": { "values": [{ "outputKey": "collect" }, { "outputKey": "generate_pdf" }, { "outputKey": "reconcile" }] },
        "fallbackOutput": "none",
        "dataType": "string",
        "value1": "={{ $json._action }}"
      },
      "id": "switch",
      "name": "ğŸ”€ Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [1100, 400]
    },
    {
      "parameters": {
        "jsCode": "// ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹åé›†è¨ˆç”»ç”Ÿæˆ\nconst data = $input.first().json;\nconst payload = data.payload || {};\nconst targets = payload.targets || ['ebay', 'amazon', 'yahoo', 'bank'];\nconst dateFrom = payload.date_from || new Date(Date.now() - 30*24*60*60*1000).toISOString().split('T')[0];\nconst dateTo = payload.date_to || new Date().toISOString().split('T')[0];\n\nconst plan = {\n  tenant_id: data._tenant_id,\n  date_range: { from: dateFrom, to: dateTo },\n  targets: targets.map(t => ({\n    platform: t,\n    evidence_types: t === 'bank' ? ['bank_statement'] : ['receipt', 'invoice', 'shipping_label'],\n    retention_years: 7\n  })),\n  ai_reasoning: {\n    pattern: 'evidence_collection',\n    confidence: 0.95,\n    factors: targets.map(t => `${t}ã‹ã‚‰ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹åé›†`)\n  }\n};\n\nreturn [{ json: { ...data, _collection_plan: plan } }];"
      },
      "id": "collect-plan",
      "name": "ğŸ“¥ åé›†è¨ˆç”»",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT dl.id, dl.transaction_type, dl.transaction_date, dl.item_name, dl.item_total_price, dl.source_platform, dl.source_transaction_id, dl.counterparty_name, dl.evidence_ids FROM dealer_ledger dl WHERE dl.tenant_id = $1 AND dl.transaction_date BETWEEN $2 AND $3 AND COALESCE(array_length(dl.evidence_ids, 1), 0) = 0 ORDER BY dl.transaction_date DESC LIMIT 100",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._collection_plan.date_range.from, $json._collection_plan.date_range.to] }}" }
      },
      "id": "get-transactions",
      "name": "ğŸ“Š å–å¼•å–å¾—",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1540, 200]
    },
    {
      "parameters": {
        "jsCode": "// ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹å‡¦ç†ãƒ»ãƒãƒƒã‚·ãƒ¥è¨ˆç®—\nconst crypto = require('crypto');\nconst data = $input.first().json;\nconst transactions = $input.all().slice(1).map(i => i.json);\n\nconst evidenceRecords = transactions.map(tx => {\n  const content = JSON.stringify({ tx_id: tx.source_transaction_id, date: tx.transaction_date, amount: tx.item_total_price });\n  const hash = crypto.createHash('sha256').update(content).digest('hex');\n  return {\n    tenant_id: data._tenant_id,\n    evidence_type: tx.transaction_type === 'purchase' ? 'receipt' : 'invoice',\n    title: `${tx.source_platform} - ${tx.item_name}`,\n    file_hash_sha256: hash,\n    evidence_timestamp: tx.transaction_date + 'T00:00:00Z',\n    related_entity_type: 'dealer_ledger',\n    related_entity_id: tx.id,\n    retention_required_until: new Date(new Date(tx.transaction_date).getTime() + 7*365*24*60*60*1000).toISOString().split('T')[0],\n    ai_confidence: 0.95\n  };\n});\n\nreturn [{ json: { ...data, _evidence_records: evidenceRecords, _stats: { total: transactions.length, created: evidenceRecords.length } } }];"
      },
      "id": "process-evidence",
      "name": "ğŸ–¼ï¸ ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹å‡¦ç†",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO evidence_registry (tenant_id, evidence_type, title, file_hash_sha256, evidence_timestamp, related_entity_type, related_entity_id, retention_required_until, ai_confidence, created_by) SELECT (r->>'tenant_id')::text, (r->>'evidence_type')::text, (r->>'title')::text, (r->>'file_hash_sha256')::text, (r->>'evidence_timestamp')::timestamptz, (r->>'related_entity_type')::text, (r->>'related_entity_id')::uuid, (r->>'retention_required_until')::date, (r->>'ai_confidence')::numeric, 'evidence_orchestrator' FROM jsonb_array_elements($1::jsonb) AS r RETURNING id",
        "options": { "queryParams": "={{ [JSON.stringify($json._evidence_records)] }}" }
      },
      "id": "insert-evidence",
      "name": "ğŸ’¾ ç™»éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1980, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// PDFç”Ÿæˆè¨­å®š\nconst data = $input.first().json;\nconst payload = data.payload || {};\nconst templateType = payload.template_type || 'police_kobutsu';\nconst dateFrom = payload.date_from || new Date(Date.now() - 30*24*60*60*1000).toISOString().split('T')[0];\nconst dateTo = payload.date_to || new Date().toISOString().split('T')[0];\n\nconst legalReqs = {\n  police_kobutsu: ['å¤ç‰©å–¶æ¥­æ³•ç¬¬16æ¡', 'å“åãƒ»ç‰¹å¾´ãƒ»æ•°é‡ãƒ»ä»£ä¾¡ãƒ»å–å¼•æ—¥æ™‚å¿…é ˆ', '1ä¸‡å††ä»¥ä¸Šã¯æœ¬äººç¢ºèª'],\n  tax_expense: ['æ³•äººç¨æ³•7å¹´ä¿å­˜', 'æ¶ˆè²»ç¨æ³•ä»•å…¥ç¨é¡æ§é™¤è¦ä»¶', 'æ—¥ä»˜ãƒ»é‡‘é¡ãƒ»å–å¼•å…ˆãƒ»å†…å®¹å¿…é ˆ'],\n  tax_journal: ['ä¼šç¤¾æ³•å¸³ç°¿ä¿å­˜', 'ä¼æ¥­ä¼šè¨ˆåŸå‰‡', 'æ—¥ä»˜ãƒ»ç§‘ç›®ãƒ»å€Ÿè²¸ãƒ»æ‘˜è¦å¿…é ˆ']\n};\n\nreturn [{ json: { ...data, _pdf_config: { tenant_id: data._tenant_id, template_type: templateType, date_range: { from: dateFrom, to: dateTo }, legal_requirements: legalReqs[templateType] || [], ai_reasoning: { template: templateType, confidence: 0.98 } } } }];"
      },
      "id": "pdf-config",
      "name": "ğŸ“„ PDFè¨­å®š",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT dl.*, dlic.license_number, dlic.business_name, dlic.business_address FROM dealer_ledger dl LEFT JOIN dealer_license dlic ON dl.license_id = dlic.id WHERE dl.tenant_id = $1 AND dl.transaction_date BETWEEN $2 AND $3 ORDER BY dl.transaction_date DESC",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._pdf_config.date_range.from, $json._pdf_config.date_range.to] }}" }
      },
      "id": "get-ledger",
      "name": "ğŸ“Š å°å¸³å–å¾—",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1540, 400]
    },
    {
      "parameters": {
        "jsCode": "// å¤ç‰©å°å¸³PDF HTMLç”Ÿæˆ\nconst data = $input.first().json;\nconst config = data._pdf_config;\nconst records = $input.all().slice(1).map(i => i.json);\nif (!records.length) return [{ json: { ...data, _pdf_html: null, _error: 'å¯¾è±¡ãƒ‡ãƒ¼ã‚¿ãªã—' } }];\n\nconst license = records[0];\nconst now = new Date().toLocaleDateString('ja-JP');\n\nconst html = `<!DOCTYPE html><html lang=\"ja\"><head><meta charset=\"UTF-8\"><title>å¤ç‰©å°å¸³</title>\n<style>@page{size:A4 landscape;margin:10mm}body{font-family:'Noto Sans JP',sans-serif;font-size:9pt}h1{text-align:center;font-size:16pt}.info{display:flex;justify-content:space-between;margin:15px 0;font-size:8pt}table{width:100%;border-collapse:collapse;font-size:7pt}th,td{border:1px solid #333;padding:3px 5px}th{background:#f0f0f0}.amt{text-align:right}.footer{margin-top:15px;font-size:7pt;text-align:right}</style></head>\n<body><h1>å¤ ç‰© å° å¸³</h1><p style=\"text-align:center\">(å¤ç‰©å–¶æ¥­æ³•ç¬¬16æ¡ã«åŸºã¥ãè¨˜éŒ²)</p>\n<div class=\"info\"><div><b>è¨±å¯ç•ªå·:</b> ${license.license_number||'____'}<br><b>å–¶æ¥­æ‰€:</b> ${license.business_name||'____'}<br><b>æ‰€åœ¨åœ°:</b> ${license.business_address||'____'}</div><div><b>æœŸé–“:</b> ${config.date_range.from} ã€œ ${config.date_range.to}<br><b>å‡ºåŠ›æ—¥:</b> ${now}<br><b>å‡ºåŠ›ç•ªå·:</b> ${data._request_id}</div></div>\n<table><thead><tr><th>å–å¼•æ—¥</th><th>ç¨®åˆ¥</th><th>å“ç›®</th><th>å“å</th><th>ç‰¹å¾´</th><th>æ•°é‡</th><th>å˜ä¾¡</th><th>é‡‘é¡</th><th>ç›¸æ‰‹æ–¹</th><th>ä½æ‰€</th><th>ç¢ºèª</th></tr></thead>\n<tbody>${records.map(r=>`<tr><td>${r.transaction_date}</td><td>${r.transaction_type==='purchase'?'è²·å—':'å£²å´'}</td><td>${r.item_category||''}</td><td>${r.item_name}</td><td>${r.item_description||''}</td><td class=\"amt\">${r.item_quantity}</td><td class=\"amt\">Â¥${Number(r.item_unit_price).toLocaleString()}</td><td class=\"amt\">Â¥${Number(r.item_total_price).toLocaleString()}</td><td>${r.counterparty_name||'çœç•¥'}</td><td>${r.counterparty_address||'çœç•¥'}</td><td>${r.verification_method||''}</td></tr>`).join('')}</tbody></table>\n<div class=\"footer\">ç·ä»¶æ•°: ${records.length}ä»¶ | è²·å—åˆè¨ˆ: Â¥${records.filter(r=>r.transaction_type==='purchase').reduce((s,r)=>s+Number(r.item_total_price),0).toLocaleString()} | å£²å´åˆè¨ˆ: Â¥${records.filter(r=>r.transaction_type==='sale').reduce((s,r)=>s+Number(r.item_total_price),0).toLocaleString()}</div>\n</body></html>`;\n\nreturn [{ json: { ...data, _pdf_html: html, _record_count: records.length } }];"
      },
      "id": "generate-html",
      "name": "ğŸ“„ HTMLç”Ÿæˆ",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 400]
    },
    {
      "parameters": {
        "jsCode": "// çªåˆãƒ­ã‚¸ãƒƒã‚¯ - éŠ€è¡Œæ˜ç´°ã¨ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åç›Šã®ãƒãƒƒãƒãƒ³ã‚°\nconst data = $input.first().json;\nconst payload = data.payload || {};\nconst dateFrom = payload.date_from || new Date(Date.now() - 30*24*60*60*1000).toISOString().split('T')[0];\nconst dateTo = payload.date_to || new Date().toISOString().split('T')[0];\n\n// çªåˆè¨ˆç”»\nconst reconcilePlan = {\n  tenant_id: data._tenant_id,\n  date_range: { from: dateFrom, to: dateTo },\n  matching_rules: [\n    { rule: 'exact_amount', priority: 1, tolerance: 0 },\n    { rule: 'date_proximity', priority: 2, days: 3 },\n    { rule: 'description_similarity', priority: 3, threshold: 0.8 },\n    { rule: 'platform_pattern', priority: 4, patterns: ['PAYPAL', 'EBAY', 'AMAZON'] }\n  ],\n  ai_reasoning: {\n    approach: 'multi_rule_matching',\n    confidence: 0.90,\n    factors: ['é‡‘é¡å®Œå…¨ä¸€è‡´', 'æ—¥ä»˜è¿‘æ¥æ€§', 'æ‘˜è¦é¡ä¼¼åº¦', 'ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³']\n  }\n};\n\nreturn [{ json: { ...data, _reconcile_plan: reconcilePlan } }];"
      },
      "id": "reconcile-plan",
      "name": "ğŸ”„ çªåˆè¨ˆç”»",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- æœªç…§åˆã®éŠ€è¡Œæ˜ç´°ã‚’å–å¾—\nSELECT bs.id, bs.transaction_date, bs.amount, bs.transaction_type, bs.description, bs.counterparty, bs.reference_number, bs.mf_category FROM bank_statements bs WHERE bs.tenant_id = $1 AND bs.transaction_date BETWEEN $2 AND $3 AND bs.matching_status = 'unmatched' ORDER BY bs.transaction_date DESC LIMIT 200",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._reconcile_plan.date_range.from, $json._reconcile_plan.date_range.to] }}" }
      },
      "id": "get-unmatched-bank",
      "name": "ğŸ“Š æœªç…§åˆæ˜ç´°",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1540, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åç›Šã‚µãƒãƒªãƒ¼ã‚’å–å¾—\nSELECT prs.id, prs.summary_date, prs.platform, prs.net_sales, prs.total_fees, prs.expected_payout, prs.actual_payout, prs.reconciliation_status FROM platform_revenue_summary prs WHERE prs.tenant_id = $1 AND prs.summary_date BETWEEN $2 AND $3 ORDER BY prs.summary_date DESC",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._reconcile_plan.date_range.from, $json._reconcile_plan.date_range.to] }}" }
      },
      "id": "get-platform-revenue",
      "name": "ğŸ“Š åç›Šã‚µãƒãƒªãƒ¼",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1760, 600]
    },
    {
      "parameters": {
        "jsCode": "// AIãƒãƒƒãƒãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯\nconst data = $input.first().json;\nconst bankStatements = $json.bank_statements || [];\nconst platformRevenue = $json.platform_revenue || [];\nconst plan = data._reconcile_plan;\n\nconst matches = [];\nconst unmatched = [];\nconst suspicious = [];\n\n// ã‚·ãƒ³ãƒ—ãƒ«ãªãƒãƒƒãƒãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šé«˜åº¦ãªAIåˆ†æã‚’ä½¿ç”¨ï¼‰\nfor (const bs of bankStatements) {\n  let matched = false;\n  let bestMatch = null;\n  let bestScore = 0;\n  \n  for (const pr of platformRevenue) {\n    let score = 0;\n    \n    // é‡‘é¡ä¸€è‡´ãƒã‚§ãƒƒã‚¯\n    const amountDiff = Math.abs(Number(bs.amount) - Number(pr.expected_payout || pr.actual_payout));\n    if (amountDiff === 0) score += 40;\n    else if (amountDiff < 100) score += 30;\n    else if (amountDiff < 1000) score += 10;\n    \n    // æ—¥ä»˜è¿‘æ¥ãƒã‚§ãƒƒã‚¯\n    const dateDiff = Math.abs(new Date(bs.transaction_date) - new Date(pr.summary_date)) / (1000*60*60*24);\n    if (dateDiff <= 1) score += 30;\n    else if (dateDiff <= 3) score += 20;\n    else if (dateDiff <= 7) score += 10;\n    \n    // æ‘˜è¦ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯\n    const desc = (bs.description || '').toUpperCase();\n    if (desc.includes(pr.platform.toUpperCase())) score += 30;\n    if (desc.includes('PAYPAL') && pr.platform === 'ebay') score += 20;\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = { bank_statement_id: bs.id, platform_revenue_id: pr.id, score: score, confidence: score / 100 };\n    }\n  }\n  \n  if (bestScore >= 70) {\n    matches.push({ ...bestMatch, status: 'auto_matched' });\n    matched = true;\n  } else if (bestScore >= 40) {\n    suspicious.push({ ...bestMatch, status: 'suspicious', reason: `ã‚¹ã‚³ã‚¢${bestScore}%ã§è‡ªå‹•ç…§åˆé–¾å€¤æœªæº€` });\n  }\n  \n  if (!matched) {\n    unmatched.push({ bank_statement_id: bs.id, amount: bs.amount, date: bs.transaction_date, description: bs.description });\n  }\n}\n\nreturn [{ json: {\n  ...data,\n  _reconcile_result: {\n    matches: matches,\n    suspicious: suspicious,\n    unmatched: unmatched,\n    stats: {\n      total_bank: bankStatements.length,\n      matched: matches.length,\n      suspicious: suspicious.length,\n      unmatched: unmatched.length,\n      match_rate: bankStatements.length > 0 ? (matches.length / bankStatements.length * 100).toFixed(1) + '%' : '0%'\n    }\n  },\n  ai_reasoning: {\n    approach: 'multi_rule_scoring',\n    rules_applied: ['amount_match', 'date_proximity', 'description_pattern'],\n    confidence: matches.length > 0 ? matches.reduce((s,m) => s + m.confidence, 0) / matches.length : 0\n  }\n} }];"
      },
      "id": "ai-matching",
      "name": "ğŸ¤– AIãƒãƒƒãƒãƒ³ã‚°",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO audit_logs (tenant_id, workflow_name, request_id, action, payload_masked, status, executed_at, metadata) VALUES ($1, 'evidence-orchestrator', $2, $3, $4::jsonb, 'success', NOW(), $5::jsonb)",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._request_id, $json._action, JSON.stringify({action: $json._action}), JSON.stringify($json.ai_reasoning || {})] }}" }
      },
      "id": "audit-log",
      "name": "ğŸ“ ç›£æŸ»ãƒ­ã‚°",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [2200, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹\nconst data = $input.first().json;\nconst action = data._action;\n\nlet result = { success: true, tenant_id: data._tenant_id, request_id: data._request_id, action: action, timestamp: new Date().toISOString() };\n\nswitch (action) {\n  case 'collect':\n    result.stats = data._stats;\n    result.evidence_count = data._evidence_records?.length || 0;\n    break;\n  case 'generate_pdf':\n    result.pdf_config = data._pdf_config;\n    result.record_count = data._record_count;\n    result.pdf_ready = !!data._pdf_html;\n    break;\n  case 'reconcile':\n    result.reconcile_result = data._reconcile_result;\n    break;\n}\n\nreturn [{ json: result }];"
      },
      "id": "final-response",
      "name": "ğŸ“Š æœ€çµ‚å¿œç­”",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2420, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": { "responseCode": 200 }
      },
      "id": "respond",
      "name": "âœ… å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2640, 400]
    }
  ],
  "connections": {
    "ğŸšª Webhook Entry": { "main": [[{ "node": "ğŸ” V8.2 Auth-Gate", "type": "main", "index": 0 }]] },
    "ğŸ” V8.2 Auth-Gate": { "main": [[{ "node": "èªè¨¼ãƒã‚§ãƒƒã‚¯", "type": "main", "index": 0 }]] },
    "èªè¨¼ãƒã‚§ãƒƒã‚¯": { "main": [[{ "node": "âŒ èªè¨¼ã‚¨ãƒ©ãƒ¼", "type": "main", "index": 0 }], [{ "node": "ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²", "type": "main", "index": 0 }]] },
    "ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²": { "main": [[{ "node": "ğŸ”€ Switch", "type": "main", "index": 0 }]] },
    "ğŸ”€ Switch": { "main": [[{ "node": "ğŸ“¥ åé›†è¨ˆç”»", "type": "main", "index": 0 }], [{ "node": "ğŸ“„ PDFè¨­å®š", "type": "main", "index": 0 }], [{ "node": "ğŸ”„ çªåˆè¨ˆç”»", "type": "main", "index": 0 }]] },
    "ğŸ“¥ åé›†è¨ˆç”»": { "main": [[{ "node": "ğŸ“Š å–å¼•å–å¾—", "type": "main", "index": 0 }]] },
    "ğŸ“Š å–å¼•å–å¾—": { "main": [[{ "node": "ğŸ–¼ï¸ ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹å‡¦ç†", "type": "main", "index": 0 }]] },
    "ğŸ–¼ï¸ ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹å‡¦ç†": { "main": [[{ "node": "ğŸ’¾ ç™»éŒ²", "type": "main", "index": 0 }]] },
    "ğŸ’¾ ç™»éŒ²": { "main": [[{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "ğŸ“„ PDFè¨­å®š": { "main": [[{ "node": "ğŸ“Š å°å¸³å–å¾—", "type": "main", "index": 0 }]] },
    "ğŸ“Š å°å¸³å–å¾—": { "main": [[{ "node": "ğŸ“„ HTMLç”Ÿæˆ", "type": "main", "index": 0 }]] },
    "ğŸ“„ HTMLç”Ÿæˆ": { "main": [[{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "ğŸ”„ çªåˆè¨ˆç”»": { "main": [[{ "node": "ğŸ“Š æœªç…§åˆæ˜ç´°", "type": "main", "index": 0 }]] },
    "ğŸ“Š æœªç…§åˆæ˜ç´°": { "main": [[{ "node": "ğŸ“Š åç›Šã‚µãƒãƒªãƒ¼", "type": "main", "index": 0 }]] },
    "ğŸ“Š åç›Šã‚µãƒãƒªãƒ¼": { "main": [[{ "node": "ğŸ¤– AIãƒãƒƒãƒãƒ³ã‚°", "type": "main", "index": 0 }]] },
    "ğŸ¤– AIãƒãƒƒãƒãƒ³ã‚°": { "main": [[{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "ğŸ“ ç›£æŸ»ãƒ­ã‚°": { "main": [[{ "node": "ğŸ“Š æœ€çµ‚å¿œç­”", "type": "main", "index": 0 }]] },
    "ğŸ“Š æœ€çµ‚å¿œç­”": { "main": [[{ "node": "âœ… å¿œç­”", "type": "main", "index": 0 }]] }
  },
  "settings": { "executionTimeout": 300, "saveDataErrorExecution": "all" },
  "tags": [{ "name": "V8.2-UNSINKABLE" }, { "name": "Evidence" }, { "name": "PDF" }, { "name": "Reconcile" }],
  "active": false,
  "_v8_version": "8.2.0"
}
