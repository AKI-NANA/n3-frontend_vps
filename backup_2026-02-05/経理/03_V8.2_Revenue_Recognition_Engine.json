{
  "name": "ã€V8.2ã€‘Revenue Recognition Engine - ç™ºç”Ÿä¸»ç¾©ä»•è¨³ã‚¨ãƒ³ã‚¸ãƒ³",
  "description": "N3 Empire OS V8.2: ç™ºç”Ÿä¸»ç¾©ã«åŸºã¥ãã€MFç­‰ã®ä¼šè¨ˆã‚½ãƒ•ãƒˆã¸é€£æºå¯èƒ½ãªä»•è¨³ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "revenue-recognition",
        "options": { "responseMode": "responseNode" }
      },
      "id": "webhook-entry",
      "name": "ğŸšª Webhook Entry",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "webhookId": "revenue-recognition",
      "position": [220, 300]
    },
    {
      "parameters": {
        "jsCode": "// V8.2 AUTH-GATE\nconst crypto = require('crypto');\nconst body = $input.first().json.body || $input.first().json || {};\nconst headers = $input.first().json.headers || {};\nconst tenantId = body.tenant_id || headers['x-tenant-id'] || 'default';\nconst signature = headers['x-n3-signature'];\nconst timestamp = headers['x-n3-timestamp'];\nconst hmacSecret = $env.N8N_HMAC_SECRET;\n\nif (hmacSecret && signature && timestamp) {\n  const tsAge = Date.now() - parseInt(timestamp);\n  if (tsAge > 300000) return [{ json: { _auth_error: true, code: 'TIMESTAMP_EXPIRED' } }];\n  const expectedHmac = crypto.createHmac('sha256', hmacSecret).update(timestamp + '.' + JSON.stringify(body)).digest('hex');\n  if (signature !== expectedHmac) return [{ json: { _auth_error: true, code: 'HMAC_INVALID' } }];\n}\n\nreturn [{ json: { _auth_passed: true, _tenant_id: tenantId, _request_id: `rev-${Date.now()}-${Math.random().toString(36).substr(2,9)}`, _timestamp: new Date().toISOString(), payload: body } }];"
      },
      "id": "auth-gate",
      "name": "ğŸ” V8.2 Auth-Gate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true },
          "conditions": [{ "leftValue": "={{ $json._auth_error }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" } }]
        }
      },
      "id": "auth-check",
      "name": "èªè¨¼ãƒã‚§ãƒƒã‚¯",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'Authentication failed' }) }}",
        "options": { "responseCode": 401 }
      },
      "id": "auth-error",
      "name": "âŒ èªè¨¼ã‚¨ãƒ©ãƒ¼",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 200]
    },
    {
      "parameters": {
        "jsCode": "// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²\nconst data = $input.first().json;\nconst action = data.payload?.action || 'generate';\nconst validActions = ['generate', 'approve', 'sync_mf', 'report'];\nif (!validActions.includes(action)) {\n  return [{ json: { ...data, _action: 'error', _error: `Invalid action: ${action}` } }];\n}\nreturn [{ json: { ...data, _action: action } }];"
      },
      "id": "action-router",
      "name": "ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 400]
    },
    {
      "parameters": {
        "rules": { "values": [{ "outputKey": "generate" }, { "outputKey": "approve" }, { "outputKey": "sync_mf" }, { "outputKey": "report" }] },
        "fallbackOutput": "none",
        "dataType": "string",
        "value1": "={{ $json._action }}"
      },
      "id": "switch",
      "name": "ğŸ”€ Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [1100, 400]
    },
    {
      "parameters": {
        "jsCode": "// è‡ªå‹•ä»•è¨³ç”Ÿæˆè¨­å®š\nconst data = $input.first().json;\nconst payload = data.payload || {};\n\nconst dateFrom = payload.date_from || new Date(Date.now() - 30*24*60*60*1000).toISOString().split('T')[0];\nconst dateTo = payload.date_to || new Date().toISOString().split('T')[0];\nconst platforms = payload.platforms || ['ebay', 'amazon', 'yahoo'];\nconst fiscalYear = payload.fiscal_year || new Date().getFullYear();\n\n// ä»•è¨³ç”Ÿæˆè¨­å®š\nconst config = {\n  tenant_id: data._tenant_id,\n  date_range: { from: dateFrom, to: dateTo },\n  platforms: platforms,\n  fiscal_year: fiscalYear,\n  auto_approve_threshold: payload.auto_approve_threshold || 10000,\n  ai_reasoning: {\n    approach: 'rule_based_journal_generation',\n    confidence: 0.95,\n    accounting_standard: 'ä¼æ¥­ä¼šè¨ˆåŸå‰‡ï¼ˆç™ºç”Ÿä¸»ç¾©ï¼‰',\n    factors: [\n      'å£²ä¸Šè¨ˆä¸Šæ™‚ç‚¹: å•†å“ç™ºé€å®Œäº†æ™‚',\n      'ä»•å…¥è¨ˆä¸Šæ™‚ç‚¹: å•†å“å—é ˜æ™‚',\n      'æ‰‹æ•°æ–™: å–å¼•ç™ºç”Ÿæ™‚ã«è²»ç”¨è¨ˆä¸Š',\n      'ç‚ºæ›¿å·®æç›Š: æ±ºæ¸ˆæ™‚ç‚¹ã®ãƒ¬ãƒ¼ãƒˆã§èªè­˜'\n    ]\n  }\n};\n\nreturn [{ json: { ...data, _journal_config: config } }];"
      },
      "id": "journal-config",
      "name": "âš™ï¸ ä»•è¨³è¨­å®š",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- è‡ªå‹•ä»•è¨³ãƒ«ãƒ¼ãƒ«ã‚’å–å¾—\nSELECT id, rule_name, priority, match_conditions, journal_template, auto_approve_threshold FROM auto_journal_rules WHERE tenant_id = $1 AND is_active = true ORDER BY priority ASC",
        "options": { "queryParams": "={{ [$json._tenant_id] }}" }
      },
      "id": "get-rules",
      "name": "ğŸ“Š ãƒ«ãƒ¼ãƒ«å–å¾—",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1540, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- ä»•è¨³æœªç”Ÿæˆã®å–å¼•ã‚’å–å¾—ï¼ˆeBayå£²ä¸Šï¼‰\nSELECT \n  'ebay_sale' as source_type,\n  id::text as source_id,\n  'ebay' as platform,\n  transaction_date as entry_date,\n  item_name as description,\n  item_total_price as total_amount,\n  item_total_price * 0.129 as platform_fee,\n  item_total_price * 0.029 as payment_fee,\n  counterparty_name\nFROM dealer_ledger\nWHERE tenant_id = $1\n  AND transaction_date BETWEEN $2 AND $3\n  AND transaction_type = 'sale'\n  AND source_platform = 'ebay'\n  AND NOT EXISTS (\n    SELECT 1 FROM journal_entries je \n    WHERE je.source_id = dealer_ledger.id::text \n    AND je.source_type = 'sales'\n  )\nORDER BY transaction_date\nLIMIT 100",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._journal_config.date_range.from, $json._journal_config.date_range.to] }}" }
      },
      "id": "get-sales",
      "name": "ğŸ“Š å£²ä¸Šå–å¾—",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1760, 200]
    },
    {
      "parameters": {
        "jsCode": "// è‡ªå‹•ä»•è¨³ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯\nconst data = $input.first().json;\nconst config = data._journal_config;\nconst rules = data._rules || [];\nconst salesData = $input.all().slice(1).map(i => i.json);\n\nconst journalEntries = [];\nconst errors = [];\nconst needsApproval = [];\n\nfor (const sale of salesData) {\n  try {\n    // ãƒ«ãƒ¼ãƒ«ãƒãƒƒãƒãƒ³ã‚°\n    let matchedRule = null;\n    for (const rule of rules) {\n      const conditions = rule.match_conditions || {};\n      let match = true;\n      \n      if (conditions.platform && !conditions.platform.includes(sale.platform)) match = false;\n      if (conditions.transaction_type && !conditions.transaction_type.includes('sale')) match = false;\n      \n      if (match) {\n        matchedRule = rule;\n        break;\n      }\n    }\n    \n    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨\n    if (!matchedRule) {\n      matchedRule = {\n        rule_name: 'default_sale',\n        auto_approve_threshold: config.auto_approve_threshold\n      };\n    }\n    \n    // é‡‘é¡è¨ˆç®—\n    const totalAmount = Number(sale.total_amount);\n    const platformFee = Number(sale.platform_fee) || totalAmount * 0.129;\n    const paymentFee = Number(sale.payment_fee) || totalAmount * 0.029;\n    const netAmount = totalAmount - platformFee - paymentFee;\n    \n    // ä»•è¨³ç•ªå·ç”Ÿæˆ\n    const journalNumber = `${config.fiscal_year}-${String(journalEntries.length + 1).padStart(6, '0')}`;\n    \n    // æ‰¿èªè¦å¦åˆ¤å®šï¼ˆæ¬¡å…ƒ5: HitLï¼‰\n    const requiresApproval = totalAmount > matchedRule.auto_approve_threshold;\n    \n    // ä»•è¨³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ç”Ÿæˆ\n    const entry = {\n      tenant_id: config.tenant_id,\n      journal_number: journalNumber,\n      fiscal_year: config.fiscal_year,\n      fiscal_period: new Date(sale.entry_date).getMonth() + 1,\n      entry_date: sale.entry_date,\n      entry_type: 'normal',\n      description: `${sale.platform.toUpperCase()}å£²ä¸Š - ${sale.description}`,\n      total_debit: totalAmount,\n      total_credit: totalAmount,\n      source_type: 'sales',\n      source_id: sale.source_id,\n      source_platform: sale.platform,\n      approval_status: requiresApproval ? 'pending' : 'auto_approved',\n      approval_required: requiresApproval,\n      is_auto_generated: true,\n      generation_rule_id: matchedRule.id || null,\n      ai_reasoning: {\n        matched_rule: matchedRule.rule_name,\n        confidence: 0.95,\n        calculation: {\n          gross_amount: totalAmount,\n          platform_fee: platformFee,\n          payment_fee: paymentFee,\n          net_amount: netAmount\n        },\n        accounting_treatment: 'ç™ºç”Ÿä¸»ç¾©ã«ã‚ˆã‚Šå•†å“ç™ºé€å®Œäº†æ™‚ç‚¹ã§å£²ä¸Šè¨ˆä¸Š'\n      },\n      lines: [\n        {\n          line_number: 1,\n          account_code: '1220',\n          account_name: 'eBay Managed Payment',\n          debit_amount: netAmount,\n          credit_amount: 0,\n          tax_category: 'exempt'\n        },\n        {\n          line_number: 2,\n          account_code: '5310',\n          account_name: 'eBayæ‰‹æ•°æ–™',\n          debit_amount: platformFee,\n          credit_amount: 0,\n          tax_category: 'non_taxable'\n        },\n        {\n          line_number: 3,\n          account_code: '5320',\n          account_name: 'PayPalæ‰‹æ•°æ–™',\n          debit_amount: paymentFee,\n          credit_amount: 0,\n          tax_category: 'non_taxable'\n        },\n        {\n          line_number: 4,\n          account_code: '4110',\n          account_name: 'eBayå£²ä¸Š',\n          debit_amount: 0,\n          credit_amount: totalAmount,\n          tax_category: 'exempt'\n        }\n      ]\n    };\n    \n    journalEntries.push(entry);\n    \n    if (requiresApproval) {\n      needsApproval.push({\n        journal_number: journalNumber,\n        amount: totalAmount,\n        reason: `é‡‘é¡${totalAmount.toLocaleString()}å††ãŒè‡ªå‹•æ‰¿èªé–¾å€¤${matchedRule.auto_approve_threshold.toLocaleString()}å††ã‚’è¶…é`\n      });\n    }\n    \n  } catch (error) {\n    errors.push({\n      source_id: sale.source_id,\n      error: error.message\n    });\n  }\n}\n\nreturn [{ json: {\n  ...data,\n  _journal_entries: journalEntries,\n  _needs_approval: needsApproval,\n  _errors: errors,\n  _stats: {\n    total_sales: salesData.length,\n    journals_created: journalEntries.length,\n    auto_approved: journalEntries.filter(j => j.approval_status === 'auto_approved').length,\n    pending_approval: needsApproval.length,\n    errors: errors.length\n  }\n} }];"
      },
      "id": "generate-journals",
      "name": "ğŸ“š ä»•è¨³ç”Ÿæˆ",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- ä»•è¨³ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç™»éŒ²\nINSERT INTO journal_entries (\n  tenant_id, journal_number, fiscal_year, fiscal_period, entry_date, entry_type,\n  description, total_debit, total_credit, source_type, source_id, source_platform,\n  approval_status, approval_required, is_auto_generated, generation_rule_id, ai_reasoning, created_by\n)\nSELECT\n  (j->>'tenant_id')::text,\n  (j->>'journal_number')::text,\n  (j->>'fiscal_year')::integer,\n  (j->>'fiscal_period')::integer,\n  (j->>'entry_date')::date,\n  (j->>'entry_type')::text,\n  (j->>'description')::text,\n  (j->>'total_debit')::numeric,\n  (j->>'total_credit')::numeric,\n  (j->>'source_type')::text,\n  (j->>'source_id')::text,\n  (j->>'source_platform')::text,\n  (j->>'approval_status')::text,\n  (j->>'approval_required')::boolean,\n  (j->>'is_auto_generated')::boolean,\n  (j->>'generation_rule_id')::uuid,\n  (j->>'ai_reasoning')::jsonb,\n  'revenue_recognition_engine'\nFROM jsonb_array_elements($1::jsonb) AS j\nRETURNING id, journal_number",
        "options": { "queryParams": "={{ [JSON.stringify($json._journal_entries)] }}" }
      },
      "id": "insert-journals",
      "name": "ğŸ’¾ ä»•è¨³ç™»éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [2200, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// æ‰¿èªå‡¦ç†\nconst data = $input.first().json;\nconst payload = data.payload || {};\n\nconst journalIds = payload.journal_ids || [];\nconst action = payload.approval_action || 'approve';\nconst approver = payload.approver || 'system';\nconst reason = payload.reason || '';\n\nif (journalIds.length === 0) {\n  return [{ json: { ...data, _error: 'æ‰¿èªå¯¾è±¡ã®ä»•è¨³IDãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“' } }];\n}\n\nreturn [{ json: {\n  ...data,\n  _approval: {\n    journal_ids: journalIds,\n    action: action,\n    approver: approver,\n    reason: reason,\n    timestamp: new Date().toISOString()\n  }\n} }];"
      },
      "id": "approve-config",
      "name": "âœ… æ‰¿èªè¨­å®š",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE journal_entries SET approval_status = CASE WHEN $2 = 'approve' THEN 'approved' WHEN $2 = 'reject' THEN 'rejected' ELSE approval_status END, approved_by = $3, approved_at = NOW(), rejection_reason = CASE WHEN $2 = 'reject' THEN $4 ELSE NULL END WHERE id = ANY($1::uuid[]) AND approval_status = 'pending' RETURNING id, journal_number, approval_status",
        "options": { "queryParams": "={{ [$json._approval.journal_ids, $json._approval.action, $json._approval.approver, $json._approval.reason] }}" }
      },
      "id": "update-approval",
      "name": "ğŸ’¾ æ‰¿èªæ›´æ–°",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1540, 400]
    },
    {
      "parameters": {
        "jsCode": "// MoneyForwardåŒæœŸè¨­å®š\nconst data = $input.first().json;\nconst payload = data.payload || {};\n\nconst journalIds = payload.journal_ids || [];\nconst syncAll = payload.sync_all || false;\n\n// MF APIè¨­å®šï¼ˆå®Ÿéš›ã¯Secret Vaultã‹ã‚‰å–å¾—ï¼‰\nconst mfConfig = {\n  api_url: $env.MF_API_URL || 'https://invoice.moneyforward.com/api/v2',\n  company_id: $env.MF_COMPANY_ID,\n  access_token: $env.MF_ACCESS_TOKEN\n};\n\nreturn [{ json: {\n  ...data,\n  _mf_config: mfConfig,\n  _sync_params: {\n    journal_ids: journalIds,\n    sync_all: syncAll\n  }\n} }];"
      },
      "id": "mf-config",
      "name": "ğŸ”„ MFè¨­å®š",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT je.*, array_agg(json_build_object('line_number', jel.line_number, 'account_code', jel.account_code, 'account_name', jel.account_name, 'debit_amount', jel.debit_amount, 'credit_amount', jel.credit_amount, 'tax_category', jel.tax_category)) as lines FROM journal_entries je JOIN journal_entry_lines jel ON je.id = jel.journal_entry_id WHERE je.tenant_id = $1 AND je.mf_sync_status = 'pending' AND je.approval_status IN ('approved', 'auto_approved') GROUP BY je.id ORDER BY je.entry_date LIMIT 50",
        "options": { "queryParams": "={{ [$json._tenant_id] }}" }
      },
      "id": "get-pending-sync",
      "name": "ğŸ“Š åŒæœŸå¾…ã¡å–å¾—",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [1540, 600]
    },
    {
      "parameters": {
        "jsCode": "// MFå½¢å¼ã«å¤‰æ›\nconst data = $input.first().json;\nconst journals = $input.all().slice(1).map(i => i.json);\n\nconst mfJournals = journals.map(j => {\n  const lines = j.lines || [];\n  return {\n    n3_journal_id: j.id,\n    journal_number: j.journal_number,\n    mf_format: {\n      deal: {\n        issue_date: j.entry_date,\n        due_date: j.entry_date,\n        summary: j.description,\n        entries_attributes: lines.map(l => ({\n          account_item_id: l.mf_account_code || l.account_code,\n          debit_amount: Number(l.debit_amount) || 0,\n          credit_amount: Number(l.credit_amount) || 0,\n          description: l.line_description || j.description\n        }))\n      }\n    }\n  };\n});\n\nreturn [{ json: {\n  ...data,\n  _mf_journals: mfJournals,\n  _sync_count: mfJournals.length\n} }];"
      },
      "id": "convert-mf",
      "name": "ğŸ”„ MFå½¢å¼å¤‰æ›",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 600]
    },
    {
      "parameters": {
        "jsCode": "// MF APIå‘¼ã³å‡ºã—ï¼ˆå®Ÿéš›ã¯HTTP Requestãƒãƒ¼ãƒ‰ã§å®Ÿè£…ï¼‰\nconst data = $input.first().json;\nconst mfJournals = data._mf_journals || [];\nconst mfConfig = data._mf_config;\n\n// ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã¯APIå‘¼ã³å‡ºã—ï¼‰\nconst results = mfJournals.map(j => ({\n  n3_journal_id: j.n3_journal_id,\n  journal_number: j.journal_number,\n  mf_journal_id: `mf-${Date.now()}-${Math.random().toString(36).substr(2,6)}`,\n  status: 'synced',\n  synced_at: new Date().toISOString()\n}));\n\nreturn [{ json: {\n  ...data,\n  _mf_results: results,\n  _sync_stats: {\n    total: mfJournals.length,\n    synced: results.filter(r => r.status === 'synced').length,\n    errors: results.filter(r => r.status === 'error').length\n  }\n} }];"
      },
      "id": "call-mf-api",
      "name": "ğŸ“¤ MF APIå‘¼å‡º",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE journal_entries SET mf_journal_id = r.mf_journal_id, mf_sync_status = 'synced', mf_sync_at = NOW() FROM (SELECT (r->>'n3_journal_id')::uuid as id, (r->>'mf_journal_id')::text as mf_journal_id FROM jsonb_array_elements($1::jsonb) AS r) r WHERE journal_entries.id = r.id",
        "options": { "queryParams": "={{ [JSON.stringify($json._mf_results)] }}" }
      },
      "id": "update-sync-status",
      "name": "ğŸ’¾ åŒæœŸçŠ¶æ…‹æ›´æ–°",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [2200, 600],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO audit_logs (tenant_id, workflow_name, request_id, action, payload_masked, status, executed_at, metadata) VALUES ($1, 'revenue-recognition', $2, $3, $4::jsonb, 'success', NOW(), $5::jsonb)",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._request_id, $json._action, JSON.stringify({action: $json._action}), JSON.stringify($json._stats || $json._sync_stats || {})] }}" }
      },
      "id": "audit-log",
      "name": "ğŸ“ ç›£æŸ»ãƒ­ã‚°",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [2420, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true },
          "conditions": [{ "leftValue": "={{ $json._needs_approval?.length > 0 }}", "rightValue": true, "operator": { "type": "boolean", "operation": "equals" } }]
        }
      },
      "id": "check-approval-needed",
      "name": "æ‰¿èªè¦å¦",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2420, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO approval_queue (tenant_id, workflow_name, request_id, payload, risk_level, policies, status) VALUES ($1, 'revenue-recognition', $2, $3::jsonb, 'MEDIUM', '[{\"rule\": \"HIGH_VALUE_JOURNAL\"}]'::jsonb, 'pending')",
        "options": { "queryParams": "={{ [$json._tenant_id, $json._request_id, JSON.stringify($json._needs_approval)] }}" }
      },
      "id": "hitl-queue",
      "name": "â¸ï¸ HitLç™»éŒ²",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "postgres-supabase", "name": "Supabase Postgres" } },
      "position": [2640, 100],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.chatwork.com/v2/rooms/{{ $env.CHATWORK_ROOM_ID }}/messages",
        "sendHeaders": true,
        "headerParameters": { "parameters": [{ "name": "X-ChatWorkToken", "value": "={{ $env.CHATWORK_API_KEY }}" }] },
        "sendBody": true,
        "bodyParameters": { "parameters": [{ "name": "body", "value": "=[info][title]ğŸ“š ä»•è¨³æ‰¿èªãƒªã‚¯ã‚¨ã‚¹ãƒˆ[/title]{{ $json._needs_approval.length }}ä»¶ã®ä»•è¨³ãŒæ‰¿èªå¾…ã¡ã§ã™\\n\\n{{ $json._needs_approval.slice(0,5).map(a => `ãƒ»${a.journal_number}: Â¥${a.amount.toLocaleString()} - ${a.reason}`).join('\\n') }}\\n\\næ‰¿èªURL: {{ $env.N3_DASHBOARD_URL }}/journals/pending[/info]" }] }
      },
      "id": "notify-approval",
      "name": "ğŸ“¢ æ‰¿èªé€šçŸ¥",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2860, 100],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹\nconst data = $input.first().json;\nconst action = data._action;\n\nlet result = { success: true, tenant_id: data._tenant_id, request_id: data._request_id, action: action, timestamp: new Date().toISOString() };\n\nswitch (action) {\n  case 'generate':\n    result.stats = data._stats;\n    result.needs_approval = data._needs_approval;\n    break;\n  case 'approve':\n    result.approval = data._approval;\n    break;\n  case 'sync_mf':\n    result.sync_stats = data._sync_stats;\n    break;\n}\n\nreturn [{ json: result }];"
      },
      "id": "final-response",
      "name": "ğŸ“Š æœ€çµ‚å¿œç­”",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": { "responseCode": 200 }
      },
      "id": "respond",
      "name": "âœ… å¿œç­”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2860, 400]
    }
  ],
  "connections": {
    "ğŸšª Webhook Entry": { "main": [[{ "node": "ğŸ” V8.2 Auth-Gate", "type": "main", "index": 0 }]] },
    "ğŸ” V8.2 Auth-Gate": { "main": [[{ "node": "èªè¨¼ãƒã‚§ãƒƒã‚¯", "type": "main", "index": 0 }]] },
    "èªè¨¼ãƒã‚§ãƒƒã‚¯": { "main": [[{ "node": "âŒ èªè¨¼ã‚¨ãƒ©ãƒ¼", "type": "main", "index": 0 }], [{ "node": "ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²", "type": "main", "index": 0 }]] },
    "ğŸ“‹ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ†å²": { "main": [[{ "node": "ğŸ”€ Switch", "type": "main", "index": 0 }]] },
    "ğŸ”€ Switch": { "main": [[{ "node": "âš™ï¸ ä»•è¨³è¨­å®š", "type": "main", "index": 0 }], [{ "node": "âœ… æ‰¿èªè¨­å®š", "type": "main", "index": 0 }], [{ "node": "ğŸ”„ MFè¨­å®š", "type": "main", "index": 0 }], [{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "âš™ï¸ ä»•è¨³è¨­å®š": { "main": [[{ "node": "ğŸ“Š ãƒ«ãƒ¼ãƒ«å–å¾—", "type": "main", "index": 0 }]] },
    "ğŸ“Š ãƒ«ãƒ¼ãƒ«å–å¾—": { "main": [[{ "node": "ğŸ“Š å£²ä¸Šå–å¾—", "type": "main", "index": 0 }]] },
    "ğŸ“Š å£²ä¸Šå–å¾—": { "main": [[{ "node": "ğŸ“š ä»•è¨³ç”Ÿæˆ", "type": "main", "index": 0 }]] },
    "ğŸ“š ä»•è¨³ç”Ÿæˆ": { "main": [[{ "node": "ğŸ’¾ ä»•è¨³ç™»éŒ²", "type": "main", "index": 0 }]] },
    "ğŸ’¾ ä»•è¨³ç™»éŒ²": { "main": [[{ "node": "æ‰¿èªè¦å¦", "type": "main", "index": 0 }]] },
    "æ‰¿èªè¦å¦": { "main": [[{ "node": "â¸ï¸ HitLç™»éŒ²", "type": "main", "index": 0 }], [{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "â¸ï¸ HitLç™»éŒ²": { "main": [[{ "node": "ğŸ“¢ æ‰¿èªé€šçŸ¥", "type": "main", "index": 0 }]] },
    "ğŸ“¢ æ‰¿èªé€šçŸ¥": { "main": [[{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "âœ… æ‰¿èªè¨­å®š": { "main": [[{ "node": "ğŸ’¾ æ‰¿èªæ›´æ–°", "type": "main", "index": 0 }]] },
    "ğŸ’¾ æ‰¿èªæ›´æ–°": { "main": [[{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "ğŸ”„ MFè¨­å®š": { "main": [[{ "node": "ğŸ“Š åŒæœŸå¾…ã¡å–å¾—", "type": "main", "index": 0 }]] },
    "ğŸ“Š åŒæœŸå¾…ã¡å–å¾—": { "main": [[{ "node": "ğŸ”„ MFå½¢å¼å¤‰æ›", "type": "main", "index": 0 }]] },
    "ğŸ”„ MFå½¢å¼å¤‰æ›": { "main": [[{ "node": "ğŸ“¤ MF APIå‘¼å‡º", "type": "main", "index": 0 }]] },
    "ğŸ“¤ MF APIå‘¼å‡º": { "main": [[{ "node": "ğŸ’¾ åŒæœŸçŠ¶æ…‹æ›´æ–°", "type": "main", "index": 0 }]] },
    "ğŸ’¾ åŒæœŸçŠ¶æ…‹æ›´æ–°": { "main": [[{ "node": "ğŸ“ ç›£æŸ»ãƒ­ã‚°", "type": "main", "index": 0 }]] },
    "ğŸ“ ç›£æŸ»ãƒ­ã‚°": { "main": [[{ "node": "ğŸ“Š æœ€çµ‚å¿œç­”", "type": "main", "index": 0 }]] },
    "ğŸ“Š æœ€çµ‚å¿œç­”": { "main": [[{ "node": "âœ… å¿œç­”", "type": "main", "index": 0 }]] }
  },
  "settings": { "executionTimeout": 300, "saveDataErrorExecution": "all" },
  "tags": [{ "name": "V8.2-UNSINKABLE" }, { "name": "Revenue" }, { "name": "Journal" }, { "name": "MoneyForward" }],
  "active": false,
  "_v8_version": "8.2.0"
}
